alias:: C++标准库的并行算法函数

- [[C++17]] 向[[标准库]]加入了并行算法函数。它们是新引人的多个函数重载，如 `std::find()` 、 `std::transform()`  和 `std: reduce()` ，其操作目标都是容器区间。相比各自对应的 “普通的” 单线程版本，这些并行版本具有相同的函数签名，只是新增了一个参数，用于设定执行策略，该参数排在参数列表最前面。举例如下。
  ```cpp
  std::vector<int> my_data;
  std::sort (std::execution::par, my_data.begin(), my_data.end());
  ```
- 通过执行策略 `std::execution:par` 向标准库示意，准许该调用采用多线程，按并行算法的形式执行。请注意，这**只是一种许可，而不是强制命令**。标准库照样可以自行决定该调用的运行方式，在单线程上执行代码。
- 我们还需注意另外 一点:并行执行方式会改变算法函数对复杂度的要求，比普通串 行算法函数对复杂度的要求略为宽松。这是因为，并行算法函数需要处理的工作总量往往更多，才可以充分发挥系统的并行算力。
	- 如果将一项任务分配到100个处理器上，但算法函数实现却令工作量变成了原来的两倍，那么整体加速比只能达到50。
- ## [[C++/execution policy]]
- ## C++标准库的并行算法函数
	- 算法函数由头文件 #<algorithm> 和 #<numeric> 给出，其中大多数具有可以指定执行策 略的重载版本。
	- 这包括：``all_of``、``any_of``、``none_of``、``for_each``、``for_each_n``、``find``、``find_if``、``find_end``、``find_first_of``、``adjacent_find``、``count``、``count_if``、``mismatch``、``equal``、``search``、``search_n``、``copy``、``copy_n``、``copy_if``、``move``、``swap_ranges``、``transform``、``replace``、``replace_if``、``replace_copy``、``replace_copy_if``、``fill``、``fill_n``、``generate``、``generate_n``、``remove``、``remove_if``、``remove_copy``、``remove_copy_if``、``unique``、``unique_copy``、``reverse``、``reverse_copy``、``rotate``、``rotate_copy``、``is_partitioned``、``partition``、``stable_partition``、``partition_copy``、``sort``、``stable_sort``、``partial_sort``、``partial_sort_copy``、``is_sorted``、``is_sorted_until``、``nth_element``、``merge``、``inplace_merge``、``includes``、``set_union``、``set_intersection``、``set_difference``、``set_symmetric_difference``、``is_heap``、``is_heap_until``、``min_element``、``max_element``、``minmax_element``、``lexicographical_compare``、``reduce``、``transform_reduce``、``exclusive_scan``、``inclusive_scan``、``transform_exclusive_scan``、``transform_inclusive_scan`` 和 ``adjacent_difference``。
	- `std:accumulate()`-函数是一个严格串行化的累加求和函数，所以不在其中，请注意类似的函数。
	  然而，[[std::reduce()]] 函数与之对应，功能更一般化，却被收入其中。C++ 标准对此给出了适当的警告：若该函数的内部操作不满足结合律和交换律，那么，由于操作次序的不明确，因此可能会导致结果不确定。
	- 对于上面列出的每个算法函数的 “普通版本”，在其参数列表最前面插入一个参数 作为执行策略，即可得到对应的重载变体(在执行策略后面，再依次给出“ 普通版本” 的原有参数)。
	- 例如 ，`std:sort()` 函数原本具有两个普通重载，都不支持执行策略。
	  ```cpp
	  template<class RandomAccessIterator>
	  void sort(RandomAccessIterator first, RandomAccessIterator last);
	  template<class RandomAccessIterator, class Compare>
	  void sort(
	    RandomAccessIterator first, RandomAccessIterator last, Compare comp);
	  ```
	  该函数还具有另外两个重载，它们可以指定执行策略，形式如下。
	  ```cpp
	  template<class ExecutionPolicy, class RandomAccessIterator>
	  void sort(
	    ExecutionPolicy&& exec,
	    RandomAccessIterator first, RandomAccessIterator last);
	  template<class ExecutionPolicy, class RandomAccessIterator, class Compare>
	  void sort(
	    ExecutionPolicy&& exec,
	    RandomAccessIterator first, RandomAccessIterator last, Compare comp);
	  ```
	- 支持执行策略与否，不仅令算法函数的签名产生区别，更会改变其中一些函数的参数，影响重大：
	  若“普通算法函数” 可接受输入迭代器或输出迭代器，则其接受执行策略的重载只接受前向迭代器。这是因输入迭代器本质上是单通(single-pass)迭代器: 我们只能通过它访问当前位置的元素，却不能将它逆转到以往位置的元素。类似地，输出选代器只准许向当前位置的元素写入，不能令它向前跳变而提早写入某个元素，再往回跳变写入之前的元素。
- ## [[C++/iterator]]
	- id:: 6637df17-a2e8-4a74-84eb-c99b1c6ef225
	  `std::copy()` 函数的普通版本的签名如下。
	  ```cpp
	  template<class InputIterator, class OutputIterator>
	  OutputIterator copy(
	    InputIterator first, InputIterator last, OutputIterator result);
	  ```
	  其支持执行策略的重载版本如下。
	  ```cpp
	  template<class ExecutionPolicy,
	    class ForwardIterator1, class ForwardIterator2>
	  ForwardIterator2 copy(
	    ExecutionPolicy&& policy,
	    ForwardIterator1 first, ForwardIterator1 last,
	    ForwardIterator2 result);
	  ```
	- 从编译器的角度出发，算法函数的模板参数的命名方式并未产生直接作用。
	  但从 C++ 标准的角度出发，标准库算法函数的模板参数的名字极具意义，它们从字面标示出对参数类型的语义约束，虽然这仅仅是源代码字面蕴含的特定语义约束（不为编译器所见），但是算法函数的实现假定该约束存在并且有效，其内部行为依赖于这些类型之上的操作。
	  考虑输入迭代器和前向迭代器需满足不同的要求：前者准许其解引用操作返回某种代理类型，并能进而转化为迭代器所指向元素的值的类型；后者则要求解引用操作返回其所指向的元素的真正引用，如果根据迭代器自身的比较运算，存在多个相等的实例，那么**这些迭代器实例返回的引用目标应该相同**。
	- 这对并行操作颇为重要：迭代器可以随意复制，副本可以等效地使用。前向迭代器还有一个重要特性：其递增操作不会令副本失效。这就使得各线程能分别操作自己的前向迭代器，在有需要的时候分别递增，无须顾虑其他线程上的副本会失效。
	  若算法函数的重载既支持设定执行策略，又准许使用[[输入迭代器]]，就会**强迫所有线程共同使用唯一一个迭代器**，通过它从数据的源序列读取值，并将涉及该选代器的访问串行化，这显然削弱了潜在的并行功能。