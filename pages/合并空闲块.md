alias:: coalescing, 合并

- ## 合并空闲块
	- 当分配器[[释放]]一个已分配块时，可能有其他空闲块与这个新释放的空闲块相邻。这些邻接的空闲块可能引起一种现象，叫做[[假碎片]], 就是有许多可用的[[空闲块]]被切割成为小的、无法使用的空闲块。
	  id:: 6578a396-c347-4fe4-93d8-948a5e5be187
	- 为了解决[[假碎片]]问题，任何实际的 *分配器* 都必须合并相邻的[[空闲块]]，这个过程称为[[合并]] (coalescing) 。这就出现了一个重要的策略决定，那就是何时执行合并。分配器可以选择立即合并 (immediate coalescing), 也就是在每次一个块被释放时，就合并所有的相邻块。或者它也可以选择推迟合并 (deferred coalescing), 也就是等到某个稍晚的时候再合并空闲块。例如，分配器可以推迟合并，直到某个分配请求失败，然后扫描整个堆，合并所有的空闲块。立即合并很简单明了，可以在常数时间内执行完成，但是对千某些请求模式，这种方式会产生一种形式的抖动，块会反复地合并，然后马上分割。例如，在图 9-38 中，反复地分配和释放一个 3 个字的块将产生大量不必要的分割和合并。在对分配器的讨论中，我们会假设使用立即合并，但是你应该了解，快速的分配器通常会选择某种形式的推迟合并。
- ## 获取额外的堆内存
	- 然而，如果[[合并空闲块]]还是不能生成一个足够大的块，或者如果空闲块已经最大程度地合并了，那么分配器就会通过调用[[sbrk 函数]]，向内核请求额外的[[堆内存]]。分配器将额外的内存转化成一个大的空闲块，将这个块插入到空闲链表中，然后将被请求的块放置在这个新的空闲块中。
-
-
-