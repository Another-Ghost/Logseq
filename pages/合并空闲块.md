alias:: coalescing, 合并

- ## 合并空闲块
	- 当分配器[[释放]]一个已分配块时，可能有其他空闲块与这个新释放的空闲块相邻。这些邻接的空闲块可能引起一种现象，叫做[[假碎片]], 就是有许多可用的[[空闲块]]被切割成为小的、无法使用的空闲块。
	  id:: 6578a396-c347-4fe4-93d8-948a5e5be187
	- 为了解决[[假碎片]]问题，任何实际的 *分配器* 都必须合并相邻的[[空闲块]]，这个过程称为[[合并]] (coalescing) 。
	  这就出现了一个重要的策略决定，那就是何时执行合并。
		- 分配器可以选择[[立即合并]], 也就是在每次一个块被释放时，就合并所有的相邻块。
		- 或者它也可以选择[[推迟合并]], 也就是等到某个稍晚的时候再合并空闲块。
		  例如，分配器可以推迟合并，直到某个分配请求失败，然后扫描整个堆，合并所有的空闲块。
	- 立即合并很简单明了，可以在常数时间内执行完成，但是对于某些请求模式，这种方式会产生一种形式的[[抖动]]，块会反复地合并，然后马上分割。
	  #+BEGIN_TIP
	  在对分配器的讨论中，我们会假设使用立即合并，但实际上快速的分配器通常会选择某种形式的[[推迟合并]]。
	  #+END_TIP
- # 带边界标记的合井
	- 分配器是如何实现合并的？让我们称想要[[释放]]的块为[[当前块]]。那么，合并（内存中的）下一个空闲块很简单而且高效。当前块的头部指向下一个块的头部，可以检查这个指针以判断下一个块是否是空闲的。如果是，就将它的大小简单地加到当前块头部的大小上，这两个块在常数时间内被合并。但是我们该如何合并前面的块呢？给定一个带头部的隐式空闲链表，唯一的选择将是搜索整个链表，记住前面块的位置，直到我们到达当前块 。 使用隐式空闲链表，这意味着每次调用 free 需要的时间都与堆的大小成线性关系。即使使用更复杂精细的空闲链表组织，搜索时间也不会是常数。 Knuth 提出了一种聪明而通用的技术，叫做边界标记 (boundary tag), 允许在常数时间内进行对前面块的合并。这种思想，如图 9-39 所示，是在每个块的结尾处添加 一 个脚部 (footer, 边界标记），其中脚部就是头部的一个副本。如果每个块包括这样一个脚部，那么分配器就可以通过检查它的脚部，判断前面一个块的起始位置和状态，这个脚部总是在距当前块开始位置一个字的距离 。考虑当分配器释放当前块时所有可能存在的情况：
- ## 获取额外的堆内存
	- 然而，如果[[合并空闲块]]还是不能生成一个足够大的块，或者如果空闲块已经最大程度地合并了，那么分配器就会通过调用[[sbrk 函数]]，向内核请求额外的[[堆内存]]。分配器将额外的内存转化成一个大的空闲块，将这个块插入到空闲链表中，然后将被请求的块放置在这个新的空闲块中。
-
-
-