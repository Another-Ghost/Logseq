alias:: C++ 执行策略, 执行策略

- C++17 标准制定了 3 种执行策略。
  title:: C++/execution policy
	- logseq.order-list-type:: number
	  [[std::execution::sequenced_policy]]
	- logseq.order-list-type:: number
	  [[std::execution::parallel_policy]]
	- logseq.order-list-type:: number
	  [[std::execution::parallel_unsequenced_policy]]
- 它们是3 个类，由头文件 #<execution> 定义。该头文件还定义了3 个对应的[[策略对象]]， 作为参数向算法函数传递。
	- logseq.order-list-type:: number
	  [[std::execution::seq]]
	- logseq.order-list-type:: number
	  [[std::execution::par]]
	- logseq.order-list-type:: number
	  [[std::execution::par_unseq]]
- 这些策略对象可能要进行特别的初始化，故我们不得从类定义直接声明创建策略对象，那样有可能导致纰漏，而新策略对象只能由这 3 个复制构造得出。程序库的实现可能具备自身特有的执行策略，因而定义出相应的执行策略的类型。但身为程序库用户， 我们无从定义自己的执行策略。
- 这些执行策略会影响算法函数的行为。根据C++标准，任何程序库的实现都可以提供额外的执行策略，并自行决定该执行策略的语义。
- ## 因指定执行策略而普遍产生的作用
	- 若向标准库的算法函数传入执行策略的参数，则函数行为受控于该策略。其行为在以下方面受到影响。
		- 算法函数的复杂度。
		- 抛出[异常时的行为。
		- 算法函数的步骤会在何时、从何处、以何种方式执行。
		- 对算法函数复杂度所产生的作用。
	- 若向算法函数提供了某执行策略，则其[[复杂度]]可能因此发生变化：并行执行需要进行额外的调度管理；除此以外，许多并行算法函数会执行更多核心操作（进行内部数据互换、执行比较操作或运行函数对象），意在改善整体性能，从而减少总运行时间。
	- 复杂度变化的精确细节因不同算法函数而异，但普遍的变化规律是，如果根据标准规定，某算法函数中的一个行为的重复次数是 $SE$（表示某种算术表达式），或重复次数最多为 $SE$ ，那么，若其重载版本按指定执行策略执行，对其复杂度的要求则放宽到 $O(SE)$ 。这种变化的含义是，若某算法函数的重载版本按指定指行策略执行，与不指定执行策略的版本相比，前者的操作数量是后者的**数倍**。其中增长的倍数取决于标准库的内部实现和系统平台的底层实现，而非传给该算法函数的数据。
	- ### [[异常]]行为
	  logseq.order-list-type:: number
		- 如果按某种执行策略调用算法函数，而期间有异常抛出，则后果取决于所选用的执行策略。如果有异常未被捕获，由C++标准给出的 3 种执行策略就会调用 `std::terminate()` 。
		  只要按标准的执行策略调用标准库的算法函数，抛出的异常其实只有一种 [[std::bad_alloc]] 异常，当程序库无法为内部操作分配足够内存资源时即抛出该异常。以
		- 下面的 `std::for_cach()` 调用为例，它并未依从任何执行策略，异常 `std::bad_alloc` 会向外传播。
		- ```cpp
		  std::for_each (v.begin(), v.end(), [](auto x){ throw my_exception (); }};
		  ``` 
		  然而，相应的重载版本依从某执行策略进行调用，则会令整个程序终止。
		  ```cpp
		  std::for_each (std::execution::seg, v.begin(), v.end (), [] (auto x) { 
		  	throw my_exception(); 
		  });
		  ```
		  上例中的一个调用依从了执行策略 `std::execution:seq` ，另一个则没有任何指定，充分展示了其异常行为的重要区别。
	- ### 算法中间步骤的执行起点和执行时机
	  logseq.order-list-type:: number
		- 这是执行策略的基本要素，也是不同执行策略之间仅有的不同点。执行策略指定了算法函数的中间步骤的[[执行主体]]（execution agent ），可能是平常的 CPU 线程、向量流（vector stream）、GPU 线程或任何其他运算单元。
		- 它还指定了算法的中间步骤存在的[[内存次序约束]]：这些步骤是否服从某种特定次序，独立的步骤之间是否可以互相交错执行，或是否可以彼此并行执行，等等。
-