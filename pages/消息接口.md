- 除了传统的内存、文件等接口之外，操作系统通常还会提供消息接口用于进程间通信。
- 消息接口将 数据 抽象成一个个的[[消息]]在两个（或多个）进程间传递。
- 需要注意，不同的 IPC 设计可以有不同的消息抽象，如[[消息队列]]中 带类型的消息结构体抽象 。
- 消息接口通常包括：
	- [[发送消息]]：`Send(message)`.
	- [[接收消息]]：`Recv(message)`.
	- [[远程方法调用]]：`RPC(req_message, resp_message)`.
	- [[回复消息]]：`Reply(resp_message)`.
- 此外，这里的参数只关注消息，实际的接口中通常包含其他选项。
- 其中，发送和接收消息的接口语义较为直接。如代码1和代码2所示，发送者可以通过 `Send` 将一个消息发送给接收者，而接收者会使用 `Recv` 来接收该消息。
	- 需要额外注意的是，在这个代码片段中，发送者和消费者需要依赖于[[通信连接]] `chan` , 将其作为一个媒介进行消息的传输。
	- ``` c
	  // 1 消息的发送
	  //  IPC的发送者
	  int main(void)
	  {
	      Message msg;
	      //chan表示发送者和消费者之间的“通信连接”
	      Channel chan simple_ipc_channel(...);
	      //按照语义生成请求消息
	      msg construct_request (...)
	      // 通过通信连接发送消息
	      Send(chan,&msg);
	  }
	  ```
	- ``` cpp
	  // 2 消息的接收
	  // IPC的接收者
	  int main(void)
	  {
	      Message msg;
	      // chan表示发送者和消费者之间的“通信连接”
	      Channel chan simple_ipc_channel(...);
	      while (1)
	      {
	        //等待一个消息的到来，这里会收到Send发送的消息
	        Recv(chan,&msg);
	        //处理消息
	        results = handle_msg(&msg);
	        ...
	      }
	    ...
	  }
	  ```
- 而[[远程方法调用]]通常可以理解成（发送端）调用 `Send` 接口后紧接着调用 `Recv` 接口，相当于在发送消息(对应`req_message`)之后，发送端还会等待一个返回消息(对应`resp_message`)。具体的区别在于[[IPC 方向性]]。
  `Reply`通常用作回复[[远程方法调用]]。
  代码3 和 代码4 给出了一个类似的例子。在这个例子中，发送者通过RPC接口向接收者发送了一个请求消息(`req_msg`), 并等待结果消息(`resp_msg`)的返回。而接收者会首先通过`Recv`接口接收消息，然后对其进行处理，并且在最后通过`Reply`接口返回结果消息给接收者，从而完成一次进程间通信。
- 代码 3 ：消息的远程方法调用：发送者  
  ``` c
  # include<simple-ipc.h> // 使用后续章节的简单IPC设计
  ...
    
  // IPC的发送者
  int main(void)
  {
      Message req_msg,resp_msg;
      // chan表示发送者和消费者之间的“通信连接”
      Channel chan simple_ipc_channel(...);
      // 按照语义生成请求消息
      req_msg construct_request (...)
      
      // 以RPC的方式调用接收者，并阻塞等待结果的返回
      RPC (chan,&req_msg,&resp_msg);
      printf("The response is:&s",msg_tostr(resp msg));
  	...
  }
  ```
- 代码 4 ：消息的远程方法调用：接受者
  ``` cpp
  # include<simple-ipc.h> // 使用后续章节的简单IPC设计
  ...
    
  // IPC的接收者
  int main(void)
  {
      Message req_msg,resp_msg;
      // chan表示发送者和消费者之间的“通信连接”
      Channel chan simple_ipc_channel(...);
    
  	while (1){
  		//等待消息的到来
  		Recv(chan,&req_msg);
  		//处理消息并构建结果消息
  		resp_msg = handle_msg(&req_msg);
  		Reply (chan,&resp_msg);
      }
      ...
  }
  ```
- 需要注意的是，这些 消息接口 可以是操作系统提供的，也可以是用户态库封装提供的。
- IPC通常包含两个阶段：准备阶段和通信阶段。
	- *准备阶段* 需要在通信的进程间建立一个[[通信连接]]，这个通信连接是打通两个隔离的进程的信道。
	- 而 *通信阶段* 通常可以进一步划分为[[数据传递]]和[[通知机制]]。
-