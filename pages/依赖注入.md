alias:: Dependency Injection, DI

- ^^依赖注入^^是一种软件设计模式，用于实现[[控制反转]]（Inversion of Control，IoC），以降低计算机代码之间的耦合度。通过依赖注入，对象的依赖关系不再由对象自身在内部创建，而是由外部系统（通常是一个框架或容器）动态地注入到使用它的对象中去。
- ### 依赖注入的核心组件：
	- **依赖对象**（Dependency）：
	  logseq.order-list-type:: number
		- 被依赖的对象，通常是作为服务提供的对象，如数据库连接、配置数据、业务逻辑等。
	- **客户类**（Client）：
	  logseq.order-list-type:: number
		- 需要依赖的对象来完成其功能的类。通过依赖注入，这些依赖在运行时被注入到客户类中，而不是由客户类自行创建。
	- **注入器**（Injector）：
	  logseq.order-list-type:: number
		- 负责创建依赖并将其注入到客户类中的组件。注入器解析客户类所需的依赖关系，并负责提供它们。
- ### 依赖注入的类型：
	- **构造函数注入**：
	  logseq.order-list-type:: number
		- 通过客户类的构造函数提供依赖，这要求创建客户对象时即提供所有必需的依赖。
	- **设置器注入**：
	  logseq.order-list-type:: number
		- 通过公共的设置器方法（setter方法）注入依赖。这允许在对象创建后的任何时刻注入依赖。
	- **接口注入**：
	  logseq.order-list-type:: number
		- 客户类实现一个或多个特定的接口，这些接口声明了注入依赖的方法。
- ### 依赖注入的优点：
	- **降低耦合度**：
	  通过从对象中移除对其依赖的直接知识和控制权，降低了系统各部分之间的耦合度。
	- **增强模块化**：
	  依赖注入支持更好的模块化，使得管理和替换依赖更为容易。
	- **提高可测试性**：
	  由于依赖可以被外部注入，可以在单元测试中轻松地将真实依赖替换为模拟对象（mocks）或存根（stubs）。
	- **灵活性和可重用性**：
	  组件更加独立，易于在不同环境下重用，例如在不同的项目或程序配置中。
- ### 示例：C++中的简单依赖注入示例
  假设有一个`Database`接口和一个使用此接口的`UserService`类，依赖通过构造函数注入：
  ```cpp
  #include <iostream>
  #include <memory>
  
  class Database {
  public:
    virtual void query(const std::string& sql) = 0;
    virtual ~Database() {}
  };
  
  class MySQLDatabase : public Database {
  public:
    void query(const std::string& sql) override {
        std::cout << "Executing SQL on MySQL: " << sql << std::endl;
    }
  };
  
  class UserService {
  private:
    std::shared_ptr<Database> db;
  public:
    UserService(std::shared_ptr<Database> db) : db(db) {}
    void addUser(const std::string& userName) {
        db->query("INSERT INTO users (name) VALUES ('" + userName + "')");
    }
  };
  
  int main() {
    auto db = std::make_shared<MySQLDatabase>();
    UserService userService(db);
    userService.addUser("Alice");
    return 0;
  }
  ```
  在这个例子中，`UserService`需要一个实现了`Database`接口的对象。`MySQLDatabase`是这个接口的具体实现。`UserService`通过其构造函数接收一个`Database`对象，实现了依赖注入，使得`UserService`的依赖可以在运行时从外部提供，增加了灵活性并简化了单元测试
- 。
- ### 注意事项：
	- **复杂性**：
	  依赖注入框架可能增加代码复杂性，尤其是在大型项目中，需要确保依赖关系清晰明了。
	- **潜在过度注入**：
	  在应用过多的依赖注入时，需要确保不要引入不必要的复杂性和冗余注入。
	- **合适的依赖管理**：
	  在构建注入器时，需要确保合适的依赖管理策略，避免资源泄漏和循环依赖。
	  依赖注入是一种强大的设计模式，可以提高代码的灵活性、模块化和可测试性，但需要根据项目需求和架构复杂度谨慎使用。