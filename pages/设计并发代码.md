# 在线程间切分任务的方法
	- ## 线程间的数据切分
	  logseq.order-list-type:: number
	- ## 依据工作类别划分任务
	  logseq.order-list-type:: number
		- ### 依据类别划分任务以分离关注点
		  logseq.order-list-type:: number
		- ### 借多线程分离关注点需防范两大风险
		  logseq.order-list-type:: number
			- 首先，我们最终可能分离出错误的关注点。其表现是多线程共享了非常多的数据，或多个线程相互等待，结果均导致线程间发生**过量通信**。我们需要检查是否有这两种表现。若有，便值得分析通信发生的缘由。假设全部通信都与同一个因素有关联，那就应该从牵涉的线程提取出相关功能，并将其整合到单一线程上，由它全权负责。或者，如果两个线程只针对彼此大量通信，却甚少与别的线程往来，则应当将两者合并为单一线程。
			- 一旦我们依据类别划分任务，思路就不会再局限于运行完全孤立的任务。若存在多组输入数据，且要按相同的操作流程进行处理，则可依照流程步骤划分任务，让各线程分别执行其中一步。
		- ### 在线程间按流程划分任务
		  logseq.order-list-type:: number
- # 影响并发代码性能的因素
	- ## 处理器的数量
	  logseq.order-list-type:: number
		- 首要因素。
		- C++11 标准线程库提供了 ``std:thread:hardware_concurrency()``，其返回值即为硬件能够并发运行的线程数目，应用程序可依此缩放实际执行任务的线程数目。
	- ## [[数据竞争]]和[[缓存乒乓]]
	  logseq.order-list-type:: number
		- [[high contention]]
	- ## [[false sharing]]
	  logseq.order-list-type:: number
	- ## 数据的紧凑程度
	  logseq.order-list-type:: number
	- ## 过度任务切换和[[线程过饱和]]
	  logseq.order-list-type:: number
- # 设计数据结构以提升多线程程序的性能
	- ## [[数组]]数据划分
		- ### 计算大型[[矩阵乘法]]
			- #### [[分块矩阵]]运算的优势
				- **提高缓存效率**：在现代计算机架构中，处理器缓存大小有限。通过将大矩阵分块处理，可以保证每个块的数据大小适合缓存，从而减少内存访问延迟。
				  logseq.order-list-type:: number
				- **并行计算**：分块矩阵使得数据更容易在多处理器或多核系统上并行处理，因为每个处理器或核心可以独立处理一个或多个矩阵块。
				  logseq.order-list-type:: number
				- **数值稳定性**：在某些数值算法中，合适的分块策略可以提高计算的数值稳定性。
				  logseq.order-list-type:: number
	- ## 其他数据结构的访问模式
- # 设计并发代码时要额外考虑的因素
	- ## [[并行算法代码中的异常安全]]
	- ## [[并发代码的可伸缩性]]
	- ## 利用多线程掩藏等待行为
		- 一如既往，增加线程的数目属于优化手段，因此改动前后均有必要测量性能以便进行对比。线程的最优数目高度依赖执行中的任务的性质，还依赖因等待而耗费的时间所占的比例。
		- 根据应用程序自身的特质，我们还是有可能利用上述的空闲CPU时间，而无须运行更多线程。臂如，假设某线程会内等待某项 I/O 操作完成而阻塞，那么，只要可以采用异步I/O，该线程就能合理地将1/O 操作放到后台执行，同时处理其他实际的工作。
		  还有一种情况，如果某线程需等待别的线程执行一项操作，该线程便有可能代执行那项操作，从而避免阳塞，我们在[[无锁队列]]中己见过这种情况。若一个线程等待某任务完成，且其他线程均尚来开始执行该任务，等待的线程则可以完整地执行这一任务。
	- ## 借并发特性改进响应能力
		-