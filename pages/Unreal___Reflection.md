alias:: Unreal reflection, 虚幻引擎反射机制, reflection system

- # 反射
	- [[反射]]是程序在运行时**自我检查**的能力。
	- 用来运行时获取一个类的信息。
- "运行时动态地查询和修改对象的属性和函数"指的是在程序运行时，能够通过代码访问并操作对象的属性（variables）和函数（methods）（**自动化的、可任意选择全局的操作目标的**），而不需要在编译时知道这些对象的具体信息（**非自动化的、特化的**）。这种能力称为运行时反射（runtime reflection）。
- 具体来说，当一个语言或框架支持运行时反射时，你可以做到以下几点：
	- **查询对象的属性和函数：** 在程序运行时，你可以获取一个对象的属性和函数列表，以及它们的类型、访问权限等信息。这使得你能够动态地了解对象的结构和行为，而无需在编写代码时提前知道这些信息。
	  logseq.order-list-type:: number
	- **修改对象的属性和函数：** 你可以在运行时修改对象的属性值，或者调用对象的方法，而无需提前知道这些属性和方法的名称和签名。这使得你能够在不修改源代码的情况下，动态地改变程序的行为。
	  logseq.order-list-type:: number
- 在游戏开发中，运行时反射通常用于实现一些高级功能，比如：
	- **脚本系统：** 允许游戏设计师在游戏运行时编写和修改脚本，以改变游戏的行为和逻辑。
	- **编辑器扩展：** 允许开发者在游戏编辑器中添加自定义功能和工具，以提高生产效率。
	- **对象[[序列化]]和反序列化：** 允许**将对象的状态保存到文件**或**从文件中加载状态**，以实现游戏的[[数据持久化]]。
- 总的来说，运行时反射为开发者提供了更灵活和强大的工具，使得他们能够在程序运行时动态地查询和修改对象的属性和函数，从而实现更多样化和复杂化的功能。
  <!--Converted by ToLogseq-->
- ## 原理
- Unreal Engine 的反射系统是其核心特性之一，使得在运行时动态地查询和修改对象的属性和方法成为可能。这种能力极大地增加了引擎的灵活性和动态性，对于编辑器功能、自动化工具、序列化和蓝图等都至关重要。下面我们详细解析 Unreal Engine 反射的底层实现原理。
	- ### **编译时代码生成** 
	  logseq.order-list-type:: number
	  Unreal Engine 的反射系统基于编译时代码生成。这是通过 Unreal Header Tool（UHT），一个在常规C++编译过程前运行的自定义预处理器来实现的。
		- **UHT的作用**：UHT扫描源代码中的宏定义（如 `UCLASS()`, `UPROPERTY()`, `UFUNCTION()` 等），这些宏标记了需要进行反射的类、属性和方法。
		- **生成元数据**：UHT为每个标记的元素生成相应的元数据和附加代码。这包括类型注册、属性访问器、序列化代码等。
		- **生成辅助结构**：例如，对于每个用 `UCLASS()` 标记的类，UHT生成一个关联的类名后加`_Generated`的辅助类，该类包含有关原始类的反射信息。
	- ### **元数据存储** 
	  logseq.order-list-type:: number
	  通过UHT生成的代码，每个反射类和成员都会在全局注册表中注册其元数据。这些元数据包括属性类型、类继承关系、方法参数、访问权限等信息。
		- **全局访问点**：Unreal Engine 维护一个全局的[[元数据注册表]]，允许运行时查询任何类或成员的元数据。
		- **动态访问**：通过[[Unity/Asset/Asset Metadata]]，引擎可以在**运行时创建对象实例、访问或修改属性、调用方法等**。
	- ### **属性系统（UProperty）** 
	  logseq.order-list-type:: number
	  Unreal 的属性系统是其反射能力的核心部分，每个用 `UPROPERTY()` 标记的成员变量都会在编译时生成特定的代码。
		- **属性访问器**：对于每个属性，UHT会生成一系列的访问器和修改器函数，这些函数允许在运行时安全地读写属性值。
		- **序列化和复制**：这些自动生成的函数还包括支持序列化和网络复制的逻辑，使得任何属性都可以轻松地持久化和在网络上同步。
	- ### **方法调用系统（UFunction）** 
	  logseq.order-list-type:: number
	  反射系统同样支持方法的动态调用。使用 `UFUNCTION()` 宏标记的方法，UHT会生成额外的包装代码。
		- **方法调度**：这些生成的代码包括方法调用的^^派发逻辑^^，**允许在运行时通过方法名称动态调用方法**。
		- **蓝图支持**：这种动态方法调用机制也支持从蓝图中调用C++定义的方法。
	- ### **运行时类型识别（[[RTTI]]）** 
	  logseq.order-list-type:: number
	  虽然 C++ 提供了自己的 RTTI 系统，但 Unreal Engine 使用自己的类型系统来更好地控制和优化性能。
		- **类型安全和验证**：自定义的类型系统不仅提高了性能，还增加了类型安全性，因为每个对象都知道自己的确切类型，并可以验证类型转换或方法调用的正确性。
- ### 总结
  Unreal Engine 的反射系统通过编译时代码生成、全局注册表、动态属性和方法调用系统实现。这个系统是非常强大的，支持高级功能如编辑器自定义、动态加载、序列化和蓝图，使 Unreal Engine 成为开发高度可定制和复杂交互游戏的强大工具。
- ## [[反射机制]]
-