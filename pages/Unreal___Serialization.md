alias:: 序列化, serialization, serialize

- Unreal Engine 中的序列化机制的底层实现涉及一系列复杂的步骤，核心由 `FArchive` 类和各种宏定义的属性系统组成。这一机制确保了数据可以在不同的存储介质（如硬盘、网络等）之间高效传输和存储。下面详细解析 Unreal Engine 的序列化底层实现原理：
- ### **FArchive 类** 
  logseq.order-list-type:: number
  `FArchive` 类是 Unreal Engine 序列化的核心。它不直接处理具体的读写操作，而是提供一个抽象的接口，定义了数据如何流入和流出。具体的存储或传输方式由 `FArchive` 的子类实现，例如内存缓冲、文件系统或网络传输等。
	- **操作符重载**：`FArchive` 通过重载 C++ 的输入输出操作符 `<<` 来简化序列化代码。这样，任何类型只要定义了如何通过这个操作符与 `FArchive` 交互，就可以被序列化和反序列化。
	- **类型适配**：对于基础数据类型（如 `int32`、`float`、`bool` 等），`FArchive` 直接支持。对于复杂类型（如自定义结构体、类等），需要开发者提供序列化逻辑。
- ### **UPROPERTY 宏** 
  logseq.order-list-type:: number
  在 Unreal Engine 中，任何需要被序列化的类成员都必须使用 `UPROPERTY` 宏进行标注。这个宏不仅标记这些成员变量以便编辑器和运行时系统识别，而且还指示引擎这些属性需要参与序列化过程。
	- **反射系统**：`UPROPERTY` 宏为 Unreal Engine 的反射系统注册属性信息，包括名称、类型、序列化方式等。
	- **自动化处理**：在运行时，序列化函数（通常是 `Serialize` 方法）可以通过反射信息自动序列化所有标记的属性，无需手动编写每个属性的序列化代码。
- ### **对象和类的序列化** 
  logseq.order-list-type:: number
	- **对象的 Serialize 方法**：每个需要被序列化的对象通常会重写其基类（通常是 `UObject`）的 `Serialize` 方法。在这个方法中，对象需要调用基类的 `Serialize` 方法来保证基类属性的序列化，然后处理自身的特定属性。
	- **处理复杂对象**：对于包含其他对象或复杂数据结构（如数组、指针等）的对象，开发者需要确保这些内容也正确地序列化。这通常意味着需要递归地调用这些对象的 `Serialize` 方法或处理指针的有效性和唯一性。
- ### **网络序列化** 
  logseq.order-list-type:: number
  网络序列化涉及更多的动态决策，如哪些数据在当前上下文中需要被发送以最小化带宽使用。Unreal Engine 提供了复制系统，该系统基于 `UPROPERTY` 宏中的 `Replicated` 或 `ReplicatedUsing` 关键字来确定哪些属性需要在网络中同步。
	- **复制条件**：复制逻辑决定了属性在什么条件下应该被同步，如只有在值改变时才同步。
	- **优化数据包**：网络序列化过程中，可能会对数据进行压缩或优化，以减少网络传输的负担。
- ### **版本控制与兼容性** 
  logseq.order-list-type:: number
  Unreal Engine 的序列化系统还支持版本控制。通过版本标记，可以在序列化数据时包含版本信息，从而在反序列化时检测并适应不同版本的数据格式，保证向前和向后的兼容性。
- Unreal Engine 的序列化底层实现强调灵活性和性能，
- 通过抽象的 `FArchive` 接口和强大的反射系统，提供了一个既通用又高效的序列化框架。这使得开发者能够轻松实现数据的保存、加载和网络同步，是构建大规模、数据驱动的游戏不可或缺的工具。
- > 序列化必要的、差异性的数据，不必要的引用不需要被序列化和反序列化。
  因此如果你的成员变量没有被[[UPROPERTY]]标记，其不会被序列化。
  如果你的这个成员变量值与默认值一致，也不会占用空间进行序列化。
- ## 应用
	- Unreal Engine 中的序列化机制承担着多个重要的角色，对游戏开发的多个方面起着关键作用。序列化是将数据或对象状态转换为可以存储或传输的格式的过程，而在 Unreal Engine 中，这一过程对于编辑器功能、游戏状态的持久化、网络复制以及资源管理都至关重要。
	- ### 游戏数据保存和加载 
	  logseq.order-list-type:: number
	  序列化在游戏数据的保存和加载中扮演核心角色。Unreal Engine 允许开发者序列化游戏世界中的对象状态到硬盘，并在需要时重新加载这些状态。这包括玩家的进度、游戏设置、已解锁的成就等。通过使用 `SaveGame` 类和标记属性为 `SaveGame` 的 `UPROPERTY`，开发者可以轻松指定哪些属性应该被保存和恢复。
	- ### 网络复制 
	  logseq.order-list-type:: number
	  在多人游戏开发中，序列化用于网络复制过程，确保多个玩家之间的游戏状态同步。Unreal Engine 使用复制（replication）来使服务器和客户端之间的游戏状态保持一致。开发者可以指定哪些对象和属性是“可复制的”，并利用引擎提供的复制逻辑自动同步这些数据。
	- ### 蓝图和C++交互 
	  logseq.order-list-type:: number
	  序列化也使得蓝图（Unreal 的视觉脚本系统）和C++代码之间的数据交互成为可能。通过序列化，蓝图可以访问和修改在C++中定义的对象的状态，反之亦然。这种灵活性极大地扩展了蓝图的能力，允许非程序员角色在不修改C++代码的情况下，通过蓝图实现复杂逻辑。
	- ### 编辑器扩展 
	  logseq.order-list-type:: number
	  Unreal Editor 使用序列化来管理编辑器中的各种设置和用户数据。这包括用户界面布局、偏好设置、工具配置等。通过序列化这些信息，Unreal Editor 能够提供高度可定制的用户体验，并允许用户在不同的工作会话之间保持一致的工作环境。
	- ### 资源管理和包装 
	  logseq.order-list-type:: number
	  Unreal Engine 中的资产，如纹理、网格和声音等，都是通过序列化过程管理的。这些资产在被导入引擎时序列化为特定格式，并在打包游戏时被进一步处理和优化。序列化使得这些资产可以高效地加载和卸载，优化内存和磁盘使用。
	- ### 动态加载和卸载 
	  logseq.order-list-type:: number
	  在大型游戏项目中，动态加载和卸载内容变得尤为重要。序列化允许游戏在运行时按需加载和卸载资源，从而优化性能和内存使用。通过序列化，游戏可以只加载玩家当前需要的内容，而将不需要的内容保持在磁盘上，待需要时再加载。
	- ### 版本控制和升级 
	  logseq.order-list-type:: number
	  随着游戏版本的更新，保持数据兼容性是一个挑战。Unreal Engine 的序列化系统支持版本控制，允许开发者在数据结构变化时提供向前和向后的兼容性。这确保了即使在游戏更新后，玩家的保存数据也能被正确地加载和使用。
- ## Reference
	- TODO https://dev.epicgames.com/documentation/zh-cn/unreal-engine/asynchronous-asset-loading-in-unreal-engine
	- TODO https://dev.epicgames.com/documentation/zh-cn/unreal-engine/asynchronous-asset-loading-in-unreal-engine
	-