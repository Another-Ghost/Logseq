- 原子操作是并发编程中的一个基本概念，指的是在多线程环境中不可分割、完成度高的操作。这意味着当一个线程正在执行原子操作时，其他线程无法观察到该操作的中间状态，只能看到操作前和操作后的状态。原子操作是实现线程安全的并发算法的关键。
- 如果读取对象的加载操作是原子的，那么这个对象的所有修改操作也是原子的，所以加载操作得到的值要么是对象的初始值，要么是某次修改操作存入的值。
- ### 特点
	- **不可中断**：一旦开始，就会一直运行到完成，不会被操作系统[[中断]]。
	- **一致性**：保证了即使在多线程环境下，操作也总是处于一致的状态。
	- **性能**：通常比锁低开销，尤其是在竞争不激烈的场景中。
- ### C++中的原子操作
  
  C++11及更高版本通过`<atomic>`头文件提供了对原子操作的支持，包括了一系列的原子类型和操作。这些原子类型如[[std::atomic]]、 [[std::atomic_flag]] 等，为基本数据类型提供了原子操作。
- ### 常见原子操作
	- **加载（Load）**：安全地读取原子对象的值。
	- **存储（Store）**：安全地设置原子对象的值。
	- **递增/递减**：原子地递增或递减原子对象的值。
	- **交换（Exchange）**：将原子对象的值设置为新值，并返回旧值。
	- **[[比较并交换]]**：如果原子对象的当前值等于给定的期望值，则将其更新为新值。
- ### 注意事项
	- 尽管原子操作能提供较好的性能，但在高竞争环境下可能会导致性能瓶颈，因为硬件通常会保证原子操作的一致性，**可能会限制并发执行**。
	- 在设计无锁数据结构时，正确理解和使用原子操作至关重要，错误的使用可能导致复杂的并发错误。
- ## [[非原子操作]]
- ## 和[[原子指令]]的区别和联系
	- **抽象层次**：原子操作是一种高级抽象，它可以通过多种方式实现，包括使用原子指令。原子指令是硬件提供的低级机制，直接由处理器执行。
	- **使用场景**：在C++编程中，开发者通常使用`std::atomic`和相关类库来执行原子操作，这隐藏了直接使用原子指令的复杂性。原子指令更多地被用于实现这些高级抽象。
- ## 用于原子操作的非 `std::atomic` 成员函数
	- 不同的原子类型中也有等价的非成员函数存在。大多数非成员函数的命名与对应成员函数有关，需要 `atomic_ `作为前缀(比如， `std::atomic_load()` )。
	  这些函数都会重载不同的原子类型，指定[[内存序]]时会分成两种：一种没有标签，另一种以 `_explicit` 为后缀，并且需要额外的参数，或将内存序作为标签，亦或只有标签(例如，`std::atomic_store(&atomic_var,new_value)` 与`std::atomic_store_explicit(&atomic_var,new_value,std::memory_orde
	  r_release` )。不过，成员函数隐式引用 *原子对象* ，所有非成员函数都持有一个指向原子对象的指针(作为第一个参数)。
	- >非成员函数的设计是为了与C语言兼容，C语言中没有引用。例如，compare_exchange_weak()和
	  compare_exchange_strong()成员函数的第一个参数(期望值)是一个引用，而std::atomic_compare_exchange_weak() (第一个参数是指向对象的指针)的第二个参数是一个指针。 std::atomic_compare_exchange_weak_explicit() 也需要指定成功和失败的内存序，而“比较/交换”成员函数都有一个单内存序(默认是 std::memory_order_seq_cst )，重载函数可以分别获取成功和失败内存序。
	- C++标准库也对原子类型中的 [[std::shared_ptr]] 智能指针类型提供非成员函数，这打破了“只有原子类型，才
	  能提供原子操作”的原则。 但可使用的原子操作有：load, store, exchange和compare/exchange，这些操作重载了标准原子类型的操作，并且可获取 `std::shared_ptr<>*` 作为第一个参数：
	- ``` cpp
	  std::shared_ptr<my_data> p;
	  void process_global_data()
	  {
	  	std::shared_ptr<my_data> local=std::atomic_load(&p);
	  	process_data(local);
	  }
	  void update_global_data()
	  {
	  	std::shared_ptr<my_data> local(new my_data);
	  	std::atomic_store(&p,local);
	  }
	  ```
	- 作为和原子操作一同使用的其他类型，也提供 _explicit 变体，允许指定所需的内存序，并且 `std::atomic_is_lock_free()` 函数可以用来确定实现是否使用锁来保证原子性。
	-