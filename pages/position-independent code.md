alias:: PIC, 位置无关代码

- #OS
- #+BEGIN_TIP
  [[共享库]]的一个主要目的就是允许多个正在运行的进程共享内存中相同的库代码，因而节约宝贵的内存资源。那么，多个进程是如何共享程序的一个副本的呢？
  #+END_TIP
	- 一种方法是给每个共享库分配一个事先预备的专用的地址空间片，然后要求加载器总是在这个地址加载共享库。虽然这种方法很简单，但是它也造成了一些严重的问题。
	  它对地址空间的使用效率不高，因为即使一个进程不使用这个库，那部分空间还是会被分配出来。
	  它也难以管理。我们必须保证没有片会重叠。每次当一个库修改了之后，我们必须确认已分配给它的片还适合它的大小。如果不适合了，必须找一个新的片。并且，如果创建了一个新的库，我们还必须为它寻找空间。
	  随着时间的进展，假设在一个系统中有了成百个库和库的各个版本库，就很难避免地址空间分裂成大量小的、未使用而又不再能使用的小洞。
	  更糟的是，对每个系统而言，库在内存中的分配都是不同的，这就引起了更多令人头痛的管理问题。
	- 要避免这些问题，现代系统以这样一种方式 *编译* [[共享模块]]的[[代码段]]，使得可以把它们**加载到[[内存]]的任何位置**而**无需 链接器 修改**。使用这种方法，无限多个[[进程]]可以共享一个 共享模块的代码段 的**单一副本**。（当然，每个进程仍然会有它自己的读／写[[数据块]]。）
- 可以加载而无需[[重定位]]的代码称为[[位置无关代码]]。
	- #+BEGIN_PINNED
	  用户对[[GCC]]使用`-fpic`选项指示 GNU编译系统 生成 PIC代码。
	  共享库的编译必须总是使用该选项。
	  #+END_PINNED
- 在一个 x86-64系统 中，对同一个[[目标模块]]中[[符号引用]]是不需要特殊处理来使之成为[[PIC]]。
  可以用[[PC 相对寻址]]来编译这些 引用 ，构造目标文件时由[[静态链接器]][[重定位]]。
- # PIC 数据引用
	- 无论我们在内存中的何处加载一个[[目标模块]]（包括[[共享目标模块]]），[[数据段]]与[[代码段]]的**距离总是保持不变**。因此，[[代码段]]中任何[[指令]]和[[数据段]]中任何[[变量]]之间的 距离 都是一个 *运行时常量* ，与 代码段 和 数据段 的[[绝对内存位置]]是无关的 。
	- 想要生成对[[全局变量]] *PIC 引用* 的[[编译器]]利用了这个事实，它在[[数据段]]开始的地方创建了一个表，叫做[[全局偏移量表]]（GOT）。
		- 在[[GOT]]中，每个被这个 目标模块 引用的 *全局数据目标*（[[过程]]或[[全局变量]]）都有一个 8 字节[[条目]]。编译器还为 GOT 中每个 条目 生成一个[[重定位记录]]。
		  在加载时，[[动态链接器]]会[[重定位]] GOT 中的每个条目，使得它包含目标的**正确的**[[绝对地址]] 。 每个引用 *全局目标* 的[[目标模块]]都有自己的 GOT。
			- 下图展示了示例 `libvector.so` 共享模块 的 GOT 。 `addvec` 例程通过 `GOT[3]` 间接地加载 全局变量`addcnt` 的地址，然后把 addcnt 在内存中加 1 。
			  因为 `addcnt` 是由 `libvector.so` 模块定义的，编译器可以利用 代码段 和 数据段 之间不变的距离，产生对 `addcnt` 的直接 [[PC 相对引用]]，并**增加一个[[重定位]]**，让[[动态链接器]]在构造这个[[共享模块]]时解析它。
			  不过，如果 `addcnt` 是由另一个[[共享模块]]定义的，那么就需要通过[[GOT]]进行 *间接访问* 。在这里，编译器选择采用最通用的解决方案，为所有的引用使用 GOT 。
			  ![image.png](../assets/image_1701274653604_0.png)
- # PIC 函数调用
	- 假设程序调用一个由 共享库 定义的[[函数]]。编译器没有办法预测这个函数的 *运行时地址*，因为定义它的共享模块在运行时可以加载到任意位置。
	  #+BEGIN_PINNED
	  正常的方法是为该引用生成一条 重定位记录 ，然后 动态链接器 在程序加载的时候再解析它。
	  不过，这种方法并不是 PIC, 因为它需要链接器修改调用模块的代码段。
	  #+END_PINNED
	   GNU 编译系统使用了一种称为[[延迟绑定]]的技术来解决这个问题, 将[[过程地址]]的 *绑定* **推迟到第一次调用该过程时**。
	- 使用[[延迟绑定]]的动机是对于一个像 `libc.so` 这样的[[共享库]]输出的成百上千个 函数 中，一个典型的[[应用程序]]只会使用其中很少的一部分 。 把 函数地址 的[解析]([[符号解析]])推迟到它实际被调用的地方，能避免动态链接器 在加载时进行成百上千个其实**并不需要的重定位**。第一次调用过程的运行时开销很大，但是其后的每次调用都只会花费 一条指令 和 一个间接的内存引用 。
	- [[延迟绑定]]是通过两个数据结构之间简洁但又有些复杂的交互来实现的，这两个 *数据结构* 是：
		- [[过程链接表]] (PLT) 。 PLT 是一个数组，其中每个条目是 16 字节代码。 每个被 可执行程序 调用的[[库函数]]都有它自己的[[PLT条目]]。每个 条目 都负责调用一个具体的 函数 。 
		  `PLT[0]` 是一个 特殊条目 ，它跳转到[[动态链接器]]中。
		  `PLT[1]` 调用[[系统启动函数]](`__libc_start_main), 它初始化 *执行环境* ，调用[[main 函数]]并处理其 *返回值* 。
		  从 `PLT[2]` 开始的条目调用 *用户代码调用的函数* 。在我们的例子中， `PLT[2]` 调用 `addvec`, `PLT[3]` 调用 `printf` 。
		- [[全局偏移量表]] (GOT) 。前面提过，GOT 是一个数组，其中每个条目是 8 字节地址。
		  和[[PLT]] 联合使用时， `GOT[0]` 和 `GOT[1]` 包含[[动态链接器]]在[[解析]][[函数地址]]时会使用的信息。 
		  `GOT[2]` 是[[动态链接器]]在 `ld_linux.so` 模块中的 *入口点* 。
		  其余的每个条目对应于一个被调用的函数，其地址需要在运行时被[解析]([[符号解析]])。每个条目都有一个相匹配的[[PLT条目]]。例如， `GOT[4]` 和 `PLT[2]` 对应于 `addvec` 。初始时，每个 [[GOT条目]]都指向对应[[PLT条目]]的**第二条指令**。
	- 如果一个[[目标模块]]调用定义在[[共享库]]中的任何 函数 ，那么它就有自己的[[GOT]]和[[PLT]]。[[GOT]] 是[[数据段]]的一部分，而[[PLT]]是代码段的一部分。
	- 图a 展示的是  GOT 和 PLT 如何协同工作，在 `addvec` 被第一次调用时，延迟解析它的运行时地址的步骤：
		- 不直接调用 `addvec` , 程序调用进入`addvec` 的 PLT条目 `PLT[2]` 。
		  logseq.order-list-type:: number
		- 第一条PLT指令通过`GOT[4]`进行[[间接跳转]]。因为每个 GOT条目 初始时都指向它对应的 PLT条目的第二条指令，这个间接跳转只是简单地把控制传送回 `PLT[2]` 中的下一条指令。
		  logseq.order-list-type:: number
		- 在把 `addvec` 的 ID (`0x1`) 压入**栈**中之后， `PLT[2]` **跳转到** `PLT[0]` 。
		  logseq.order-list-type:: number
		- `PLT[0]` 通过 `GOT[1]` 间接地把 动态链接器的一个参数 压入**栈**中，然后通过 `GOT[2]` 间接跳转进动态链接器中。动态链接器使用 两个栈条目（`addvec`的ID 和 动态链接器的一个参数 ）来确定 `addvec` 的 *运行时位置* ，用这个地址**重写** `GOT [4]` , 再把**控制传递给** `addvec` 。
		  logseq.order-list-type:: number
	- 图 b 给出的是后续再调用 `addvec` 时的控制流：
	  logseq.order-list-type:: number
		- 和前面一样，控制传递到 `PLT[2]` 。
		  logseq.order-list-type:: number
		- 这次通过 `GOT[4]` 的间接跳转会将控制直接转移到 `addvec` 。
		  logseq.order-list-type:: number
		- ![image.png](../assets/image_1701284043158_0.png)