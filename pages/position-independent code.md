alias:: PIC, 位置无关代码

- #OS
- #+BEGIN_TIP
  [[共享库]]的一个主要目的就是允许多个正在运行的进程共享内存中相同的库代码，因而节约宝贵的内存资源。那么，多个进程是如何共享程序的一个副本的呢？
  #+END_TIP
	- 一种方法是给每个共享库分配一个事先预备的专用的地址空间片，然后要求加载器总是在这个地址加载共享库。虽然这种方法很简单，但是它也造成了一些严重的问题。
	  它对地址空间的使用效率不高，因为即使一个进程不使用这个库，那部分空间还是会被分配出来。
	  它也难以管理。我们必须保证没有片会重叠。每次当一个库修改了之后，我们必须确认已分配给它的片还适合它的大小。如果不适合了，必须找一个新的片。并且，如果创建了一个新的库，我们还必须为它寻找空间。
	  随着时间的进展，假设在一个系统中有了成百个库和库的各个版本库，就很难避免地址空间分裂成大量小的、未使用而又不再能使用的小洞。
	  更糟的是，对每个系统而言，库在内存中的分配都是不同的，这就引起了更多令人头痛的管理问题。
	- 要避免这些问题，现代系统以这样一种方式 *编译* [[共享模块]]的[[代码段]]，使得可以把它们**加载到[[内存]]的任何位置**而**无需 链接器 修改**。使用这种方法，无限多个[[进程]]可以共享一个 共享模块的代码段 的**单一副本**。（当然，每个进程仍然会有它自己的读／写[[数据块]]。）
- 可以加载而无需[[重定位]]的代码称为[[位置无关代码]]。
	- #+BEGIN_PINNED
	  用户对[[GCC]]使用-fpic选项指示 GNU编译系统生成 PIC代码。共享 库的编译必须总是使用该选项。
	  #+END_PINNED
- 在一个 x86-64系统 中，对同一个[[目标模块]]中[[符号引用]]是不需要特殊处理来使之成为[[PIC]]。
  可以用[[PC 相对寻址]]来编译这些 引用 ，构造目标文件时由[[静态链接器]][[重定位]]。
- # PIC 数据引用
	- 无论我们在内存中的何处加载一个[[目标模块]]（包括[[共享目标模块]]），[[数据段]]与[[代码段]]的**距离总是保持不变**。因此，[[代码段]]中任何[[指令]]和[[数据段]]中任何[[变量]]之间的 距离 都是一个 *运行时常量* ，与 代码段 和 数据段 的[[绝对内存位置]]是无关的 。
	- 想要生成对[[全局变量]] *PIC 引用* 的[[编译器]]利用了这个事实，它在[[数据段]]开始的地方创建了一个表，叫做[[全局偏移量表]]（GOT）。
		- 在[[GOT]]中，每个被这个 目标模块 引用的 *全局数据目标*（[[过程]]或[[全局变量]]）都有一个 8 字节[[条目]]。编译器还为 GOT 中每个 条目 生成一个[[重定位记录]]。
		  在加载时，[[动态链接器]]会[[重定位]] GOT 中的每个条目，使得它包含目标的**正确的**[[绝对地址]] 。 每个引用 *全局目标* 的[[目标模块]]都有自己的 GOT。
			- 下图展示了示例 `libvector.so` 共享模块 的 GOT 。 `addvec` 例程通过 `GOT[3]` 间接地加载 全局变量`addcnt` 的地址，然后把 addcnt 在内存中加 1 。
			  因为 `addcnt` 是由 `libvector.so` 模块定义的，编译器可以利用 代码段 和 数据段 之间不变的距离，产生对 `addcnt` 的直接 [[PC 相对引用]]，并**增加一个[[重定位]]**，让[[动态链接器]]在构造这个[[共享模块]]时解析它。不过，如果 addcn 七是由另一个共享模块定义的，那么就需要通过 GOT 进行间接访问。在这里，编译器选择采用最通用的解决方案，为所有的引用使用 GOT 。
			  ![image.png](../assets/image_1701274653604_0.png)