alias:: linker

- [[可重定位目标文件]]纯粹是字节块的集合。这些块中，有些包含程序代码，有些包含程序数据，而其他的则包含**引导**[[链接器]]和[[加载器]]的数据结构。
  [[链接器]]将这些块连接起来，确定被连接块的运行时位置，并且修改代码和数据块中的各种位置。
- > 链接器对目标机器了解甚少。产生目标文件的编译器和汇编器已经完成了大部分工作。
- # [[符号解析]]
	- 链接器 解析[[符号引用]]的方法是将每个[[引用]]与它输入的[[可重定位目标文件]]的[[符号表]]中的一个确定的[[符号定义]]关联起来。
	- ## [[局部符号]]
		- 对那些和[[引用]]定义在相同模块中的[[局部符号]]的引用，符号解析 是非常简单明了的。**[[编译器]]只允许每个[[模块]]中每个[[局部符号]]有一个定义**。
		  [[静态局部变量]]也会有[[本地链接器符号]]，[[编译器]]还要确保它们拥有**唯一的名字**。
	- ## [[全局符号]]
		- 不过，对全局符号的引用解析就棘手得多。当[[编译器]]遇到一个不是在当前[[模块]]中定义的符号（变量 或 函数名）时，会假设该符号是在其他某个模块中定义的，生成一个[[链接器符号表条目]]，并把它交给[[链接器]]处理。如果链接器在它的任何[[输入模块]]中都找不到这个 被引用符号 的定义，就输出一条（通常很难阅读的）错误信息并终止。
		- #+BEGIN_TIP
		  C++ 和 Java 中能使用[[重载函数]]，是因为编译器将每个唯一的方法和参数列表组合编码成一个对[[链接器]]来说唯一的名字 。这种编码过程叫做重整 ([[mangling]])，而相反的过程叫做恢复 ([[demangling]]) 。
		  方法被编码为原始 方法名 ，后面加上＿，加上被重整的 类名 ，再加上每个参数的单字母编码 。
		  比如，`Foo: :bar(int, long)` 被编码为 `bar__ 3Fooil` 。[[重整]][[全局变量]]和[[模板]]名字的策略是相似的 。
		  #+END_TIP
		- ### 链接器如何解析多重定义的全局符号
			- 在编译时，[[编译器]]向[[汇编器]]输出每个[[全局符号]]，
				- [[函数]]和 *已初始化的全局变量* 是[[强符号]]，
				- *未初始化的全局变量* 是[[弱符号]]。
			- 而汇编器把这个信息隐含地编码在 可重定位目标文件 的[[符号表]]里。
			- 根据强弱符号的定义，[[Linux]]链接器 使用下面的规则来处理多重定义的符号名：
				- **不允许有多个同名的**[[强符号]]。
				  logseq.order-list-type:: number
				- 如果有一个 强符号 和多个[[弱符号]]同名，那么选择强符号。
				  logseq.order-list-type:: number
				- 如果有多个 弱符号 同名，那么从这些弱符号中**任意**选择一个。
				  logseq.order-list-type:: number
			- #+BEGIN_TIP
			  
			  #+END_TIP
		-
-
-