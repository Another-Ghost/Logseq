alias:: linker

- [[可重定位目标文件]]纯粹是字节块的集合。这些块中，有些包含程序代码，有些包含程序数据，而其他的则包含**引导**[[链接器]]和[[加载器]]的数据结构。
  [[链接器]]将这些块连接起来，确定被连接块的运行时位置，并且修改代码和数据块中的各种位置。
- > 链接器对目标机器了解甚少。产生目标文件的编译器和汇编器已经完成了大部分工作。
- # [[符号解析]]
	- 链接器 解析[[符号引用]]的方法是将每个[[引用]]与它输入的[[可重定位目标文件]]的[[符号表]]中的一个确定的[[符号定义]]关联起来。
	- ## [[局部符号]]
		- 对那些和[[引用]]定义在相同模块中的[[局部符号]]的引用，符号解析 是非常简单明了的。**[[编译器]]只允许每个[[模块]]中每个[[局部符号]]有一个定义**。
		  [[静态局部变量]]也会有[[本地链接器符号]]，[[编译器]]还要确保它们拥有**唯一的名字**。
	- ## [[全局符号]]
		- 不过，对全局符号的引用解析就棘手得多。当[[编译器]]遇到一个不是在当前[[模块]]中定义的符号（变量 或 函数名）时，会假设该符号是在其他某个模块中定义的，生成一个[[链接器符号表条目]]，并把它交给[[链接器]]处理。如果链接器在它的任何[[输入模块]]中都找不到这个 被引用符号 的定义，就输出一条（通常很难阅读的）错误信息并终止。
		- #+BEGIN_TIP
		  C++ 和 Java 中能使用[[重载函数]]，是因为编译器将每个唯一的方法和参数列表组合编码成一个对[[链接器]]来说唯一的名字 。这种编码过程叫做重整 ([[mangling]])，而相反的过程叫做恢复 ([[demangling]]) 。
		  方法被编码为原始 方法名 ，后面加上＿，加上被重整的 类名 ，再加上每个参数的单字母编码 。
		  比如，`Foo: :bar(int, long)` 被编码为 `bar__ 3Fooil` 。[[重整]][[全局变量]]和[[模板]]名字的策略是相似的 。
		  #+END_TIP
		- ### 链接器如何解析多重定义的全局符号
			- 在编译时，[[编译器]]向[[汇编器]]输出每个[[全局符号]]，
				- [[函数]]和 *已初始化的全局变量* 是[[强符号]]，
				- *未初始化的全局变量* 是[[弱符号]]。
			- 而汇编器把这个信息隐含地编码在 可重定位目标文件 的[[符号表]]里。
			- 根据强弱符号的定义，[[Linux]]链接器 使用下面的规则来处理多重定义的符号名：
				- **不允许有多个同名的**[[强符号]]。
				  logseq.order-list-type:: number
				- 如果有一个 强符号 和多个[[弱符号]]同名，那么选择强符号。
				  logseq.order-list-type:: number
				- 如果有多个 弱符号 同名，那么从这些弱符号中**任意**选择一个。
				  logseq.order-list-type:: number
				- #+BEGIN_TIP
				  ``` cpp
				  /* foo3.c */
				  #include <stdio.h>
				  void f(void);
				  int x = 15213;
				  int main()
				  {
				    f();
				    printf("x = %d\n", x);
				    return 0;
				  }
				  
				  /* bar3.c */
				  int x;
				  void f()
				  {
				    x = 15212;
				  }
				   = 15212;7 }
				  ``` 
				  在运行时，函数`f`将`x`的值由 15213 改为 15212, 这会给`main`函数的作者带来困惑！
				  注意，链接器通常不会表明它检测到多个`x`的定义：
				  ``` shell
				  linux> gcc -o foobar3 foo3.c bar3.c
				  linux> ./foobar3
				  x = 15212
				  ```
				  #+END_TIP
					- >测试[[Windows]]上没有这种问题，会报链接错误：Error LNK2005 和 LNK1169
				- 规则2 和 规则3 的应用会造成一些不易察觉的**运行时**错误，尤其是如果重复的符号定义还有不同的 *类型* 时。
				  当你怀疑有此类错误时，用像`GCC-fno-common`标志这样的选项调用 链接器，这个选项会告诉链接器，在遇到多重定义的全局符号时，触发一个错误。或者使用`-Werror`选项，它会把所有的警告都变为错误。
				- 当编译器在翻译某个模块时，遇到一个弱全局符号，比如说 x, 它并不知道其他模块是否也定义了 x, 如果是，它无法预测链接器该使用 x 的多重定义中的哪一个。所以编译器把 x 分配成 COMMON, 把决定权留给链接器。
				  另一方面，如果 x 初始化为 o, 那么它是一个强符号（因此根据规则 2 必须是唯一的），所以编译器可以很自信地将它分配成 .bss 。
				  #+BEGIN_TIP
				  类似地，静态符号的构造就必须是唯一的，所以编译器可以自信地把它们分配成 .data 或 .bss 。
				  #+END_TIP
		-
-
-