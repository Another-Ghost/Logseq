id:: 655cdcf6-86ed-408b-beb4-bc9c88bcbad0
alias:: 非局部变量

- 所有具有[[静态存储期]]的[[非局部变量]]都作为[[程序启动]]的一部分进行[[初始化]]，在[[main]]函数的执行开始之前（除非是[[Deferred dynamic initialization]]）。
- 所有具有[[线程存储期]]的[[非局部变量]]都作为[[线程启动]]的一部分进行初始化，在[[线程函数]]**执行开始之前**顺序先行。
- 对于这两类变量，初始化发生在两个不同的阶段：
	- ## [[静态初始化]]
		- 静态初始化有两种形式：
			- 如果可能，应用[[常量初始化]]，
			- 否则，对 [[non-local static variable]] 和 [[static_local]]变量 进行[[零初始化]]。
		- 实践中：
			- 常量初始化 通常在 编译期 应用。预先计算的 对象表示形式 存储为 程序映像 的一部分。
			  如果编译器没有这样做，它仍然必须保证在任何[[动态初始化]]之前完成初始化。
			- 要进行[[零初始化]]的变量放置在 程序映像 的[[.bss]]中。
	- ## [[动态初始化]]
		- 在所有[[静态初始化]]完成后，非局部变量的[[动态初始化]]在以下情况下发生：
			- 无序动态初始化，仅适用于未[[explicitly specialized]]的（static/thread_local）[[类模板]]静态数据成员和[[变量模板]]（自[[C++14]]起）。这些 静态变量 的初始化与所有其他 动态初始化 不定顺序，除非程序**在变量初始化之前 启动线程**，在这种情况下，其初始化是确定无序的（自 [[C++17]]起）。这些 thread_local 变量的初始化与所有其他动态初始化无序。
			  logseq.order-list-type:: number
			  id:: 655b8947-1c40-45ad-9be5-e77175b52ac8
			- 部分有序动态初始化，适用于所有非 隐式或显式实例化特化 的[[内联变量]]。如果在每个[[翻译单元]]中部分有序的 V 在有序或部分有序的 W **之前定义**，则 V 的初始化在 W 的初始化之前顺序先行（或在程序启动线程时先发生）（自[[C++17]]起）。
			  logseq.order-list-type:: number
			- 有序动态初始化，适用于所有**其他**非局部变量：在单个翻译单元内，这些变量的初始化总是按照**它们在源代码中出现的确切顺序**进行。
			  logseq.order-list-type:: number
			  **不同[[翻译单元]]中** 静态变量的初始化 是**不定顺序的**。不同翻译单元中 thread_local变量 的初始化是无序的。
			  如果具有静态或线程存储期的非局部变量的初始化通过异常退出，将调用 `std::terminate`。
		- ## [[Early dynamic initialization]]
			- [[编译器]]被允许在[[静态初始化]]期间（实质上是在[[编译期]]）初始化[[动态初始化]]的变量，如果以下条件都成立：
				- [[动态初始化]]的版本**不改变任何**命名空间作用域对象的值，直到其初始化。
				  logseq.order-list-type:: number
				- [[静态初始化]]的版本在被初始化的变量中产生的值与 所有 不需要静态初始化的变量 动态初始化时 产生的值相同。
				  logseq.order-list-type:: number
			- 由于上述规则，如果某个对象 o1 的初始化引用了命名空间作用域对象 o2，后者可能需要动态初始化，但在同一翻译单元中定义在后面，那么使用的 o2 的值是不确定的，可能是完全初始化的 o2 的值（因为编译器将 o2 的初始化提升到了编译时）或仅是零初始化的 o2 的值。
			- ``` cpp
			  inline double fd() { return 1.0; }
			   
			  extern double d1;
			   
			  double d2 = d1;   // 不确定：
			                    // 如果 d1 是动态初始化，则动态初始化为 0.0，或者
			                    // 如果 d1 是静态初始化，则动态初始化为 1.0，或者
			                    // 静态初始化为 0.0（因为如果两个变量都是动态初始化，那将是其值）
			   
			  double d1 = fd(); // 可能静态初始化或动态初始化为 1.0
			  
			  ```
		- ## [[Deferred dynamic initialization]]
			- 实现定义了[[动态初始化]]是在 `main` 函数的第一个语句之前（对于[[静态变量]]）还是 *线程的初始函数* 之前（对于[[thread_local变量]]）发生，还是 延迟 到之后发生。
			- 如果非[[内联变量]]的初始化被延迟到 `main`线程函数 的第一个语句之后发生，它发生在同一[[翻译单元]]中定义的任何具有静态/线程存储期的变量的第一次[[odr-use]]之前。
			  如果一个给定的翻译单元中没有变量或函数被 odr-use，则该翻译单元中定义的非局部变量可能永远不会初始化（这模拟了按需[[动态库]]的行为）。然而，只要从一个翻译单元中 odr-use 了任何东西，所有具有副作用的初始化或销毁的非局部变量都将被初始化，即使它们在程序中没有被使用。
			- 如果内联变量的初始化被延迟，则在该特定变量的第一次 odr-use 之前发生。
- # 和[[全局变量]]关系
- [[全局变量]]具有[[外部链接]]，[[static全局变量]]只具有[[内部链接]]。
- #DOING
-