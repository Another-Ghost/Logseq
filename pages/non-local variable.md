alias:: 非局部变量

- 所有具有[[静态存储期]]的[[非局部变量]]都作为[[程序启动]]的一部分进行[[初始化]]，在[[main]]函数的执行开始之前（除非是[[Deferred dynamic initialization]]）。
- 所有具有[[线程存储期]]的[[非局部变量]]都作为[[线程启动]]的一部分进行初始化，在[[线程函数]]**执行开始之前**顺序先行。
- 对于这两类变量，初始化发生在两个不同的阶段：
	- ## [[静态初始化]]
		- 静态初始化有两种形式：
			- [[常量初始化]]。
			  logseq.order-list-type:: number
			- 对 [[non-local static variable]] 和 [[static_local]]变量 进行[[零初始化]]。
			  logseq.order-list-type:: number
		- 实践中：
			- 常量初始化 通常在 编译期 应用。预先计算的 对象表示形式 存储为 程序映像 的一部分。
			  如果编译器没有这样做，它仍然必须保证在任何[[动态初始化]]之前完成初始化。
			- 要进行[[零初始化]]的变量放置在 程序映像 的[[.bss]]中。
	- ## [[动态初始化]]
		- 在所有[[静态初始化]]完成后，非局部变量的[[动态初始化]]在以下情况下发生：
			- 无序动态初始化，仅适用于未显式专门化的（静态/线程局部）类模板静态数据成员和变量模板（自 C++14 起）。这些静态变量的初始化与所有其他动态初始化不定顺序，除非程序在变量初始化之前启动线程，在这种情况下，其初始化是无序的（自 C++17 起）。这些线程局部变量的初始化与所有其他动态初始化无序。
			  logseq.order-list-type:: number
			  2) 部分有序动态初始化，适用于所有非隐式或显式实例化专门化的内联变量。如果在每个翻译单元中部分有序的 V 在有序或部分有序的 W 之前定义，则 V 的初始化在 W 的初始化之前顺序先行（或在程序启动线程时先发生）（自 C++17 起）。
			  3) 有序动态初始化，适用于所有其他非局部变量：在单个翻译单元内，这些变量的初始化总是按照它们在源代码中出现的确切顺序进行。不同翻译单元中静态变量的初始化是不定顺序的。不同翻译单元中线程局部变量的初始化是无序的。
			  如果具有静态或线程存储期的非局部变量的初始化通过异常退出，将调用 `std::terminate`。
- #### 早期动态初始化
  编译器被允许在静态初始化期间（实质上是在编译时）初始化动态初始化的变量，如果以下条件都成立：
  
  1) 动态初始化的版本不改变任何命名空间作用域对象的值，直到其初始化。
  2) 静态初始化的版本在被初始化的变量中产生的值与所有不需要静态初始化的变量动态初始化时产生的值相同。
  
  由于上述规则，如果某个对象 o1 的初始化引用了命名空间作用域对象 o2，后者可能需要动态初始化，但在同一翻译单元中定义在后面，那么使用的 o2 的值是不确定的，可能是完全初始化的 o2 的值（因为编译器将 o2 的初始化提升到了编译时）或仅是零初始化的 o2 的值。
- #### 延迟的动态初始化
  实现定义了动态初始化是在 `main` 函数的第一个语句之前（对于静态变量）还是线程的初始函数之前（对于线程
  
  局部变量）发生，还是延迟到之后发生。
  
  如果非内联变量（自 C++17 起）的初始化被延迟到 `main`/线程函数的第一个语句之后发生，它发生在同一翻译单元中定义的任何具有静态/线程存储期的变量的第一次 odr-use 之前。如果一个给定的翻译单元中没有变量或函数被 odr-use，则该翻译单元中定义的非局部变量可能永远不会初始化（这模拟了按需动态库的行为）。然而，只要从一个翻译单元中 odr-use 了任何东西，所有具有副作用的初始化或销毁的非局部变量都将被初始化，即使它们在程序中没有被使用。
  
  如果内联变量的初始化被延迟，则在该特定变量的第一次 odr-use 之前发生。
- #### 静态局部变量
  有关局部（即块作用域）静态和线程局部变量的初始化，请参见静态局部变量。
- #### 类成员
  非静态数据成员可以用成员初始化列表或默认成员初始化器初始化。
-