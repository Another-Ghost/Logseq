alias:: 无阻塞并发数据结构, 无阻塞数据结构, nonblocking data structure

- #+BEGIN_TIP
  互斥锁是一种强大的机制，可以确保多个线程可以安全地访问数据结构，而不会遇到竞态条件或破坏不变性。使用它们的代码行为也相对直接易理解：代码要么持有保护数据的互斥锁，要么不持有。
  但这并不都是好处；锁的不正确使用可能导致死锁，锁的粒度会影响真正并发的潜力。如果你能编写无需锁即可安全并发访问的数据结构，就有可能避免这些问题。这种数据结构被称为无锁数据结构。
  #+END_TIP
- ## 定义及其后果
- 使用互斥锁、条件变量和期望（futures）来同步数据的算法和数据结构被称为^^[[阻塞]]（blocking）数据结构和算法^^。
  应用程序调用库函数，这些库函数将暂停线程的执行，直到另一个线程执行某个动作。这些库调用被称为^^阻塞调用（blocking call）^^，因为线程不能在此点之后继续执行，直到阻塞被移除。
- 不使用阻塞库函数的数据结构和算法被称为[[非阻塞]]（nonblocking）。然而，并非所有这些数据结构都是无锁的，因此我们来看看非阻塞数据结构的各种类型。
- ### [[非阻塞]]数据结构的类型
- 之前我们使用 `std::atomic_flag` 实现了一个基本的[[自旋锁]]：
  ``` cpp
  class spinlock_mutex
  {
      std::atomic_flag flag;
  public:
      spinlock_mutex() :
          flag(ATOMIC_FLAG_INIT)
      {}
  
      void lock()
      {
          while (flag.test_and_set(std::memory_order_acquire));
      }
      
      void unlock()
      {
          flag.clear(std::memory_order_release);
      }
  };
  ``` 
  这段代码没有调用任何阻塞函数；`lock()` 会一直循环，直到对 `test_and_set()` 的调用返回 `false`。这就是为什么它被称为自旋锁——代码在循环中“自旋”。没有阻塞调用，所以任何使用这个互斥锁来保护共享数据的代码因此是非阻塞的。然而，它并不是无锁的。它仍然是一个互斥锁，并且一次只能由一个线程锁定。出于这个原因，在大多数情况下，仅知道某个东西是非阻塞的还不够。相反，你需要知道这里定义的哪些（如果有的话）更具体的术语适用。这些术语包括：
	- **[[无阻碍]]（Obstruction-Free）** ——如果所有其他线程都**暂停**了，那么任何给定的线程将在**有限的步数内完成**其操作。
	- **[[无锁]]（Lock-Free）** ——如果多个线程在操作一个数据结构，那么在**有限的步数**后，**其中一个线程将完成**其操作。
	- **[[无等待]]（Wait-Free）** ——**每个在数据结构上操作的线程将在有限的步数内完成**其操作，即使其他线程也在操作这个数据结构。
- 大多数情况下，[[无阻碍]]的算法并不特别有用——很少有所有其他线程都暂停的情况，因此这更多的是对失败的无锁实现的描述。
- ## [[无锁数据结构]]
- ## [[无等待数据结构]]