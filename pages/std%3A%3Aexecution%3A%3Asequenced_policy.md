alias:: 顺序策略, sequenced policy, std::execution::seq

- ^^顺序策略^^（sequenced policy）与并行无关：它令算法函数在发起调用的线程上执行全部操作，因而不会发生并行。但它依然是一种执行策略，故其执行效果与别的标准执行策略相同，对算法复杂度和异常行为所产生的影响也相同。
- 所有操作不但要由同一个线程执行，还必须服从一定的次序，不存在交错执行。C++标准并未为此详细规定内存次序，算法函数所服从的内存次序可能因调用不同而不同。
  具体而言，若某算法函数的重载按指定执行策略而执行，与没有指定执行策略的版本相比，两者服从的内存次序可能有异。以下面的 std:for_cach（次例，它会将1~1000的数字填入 vector 容器，但填充次序并不确定。但是，如果没有为算法函数指定执行策略，则数字会按顺序填人。
- ```cpp
  std::vector<int> v(1000);
  int count=0;
  std::for_each(std::execution::seq,v.begin(),v.end(),
    [&](int& x){ x=++count; });
  ```
- 虽然本例的数字有可能按顺序填人，但我们不能假设该填人操作服从确定的次序。 
  换言之，针对算法函数用到的各种迭代器、值和可调用对象，`std::execution::sequenced_policy` 几乎没有施加内存次序限制：它们之间可以自由选择同步机制，也会因同一线程上的操作而发生变化，但不得假设存在完全确定的操作次序。
-