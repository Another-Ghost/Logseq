alias::  std::atomic<UDT>

- 模板允许用户使用自定义类型创建一个原子变量(除了标准原子类型之外)，需要满足一定的标准才可以使用 `std::atomic<>` 。为了使用 `std::atomic<UDT>` ，这个类型不能有任何虚函数或虚基类，以及必须使用编译器创建的[[拷贝赋值操作]]。不仅仅是这些，自定义类型中所有的基类和非静态数据成员也都需要支持拷贝赋值操作。这(基本上)就允许编译器使用[[memcpy()]]或赋值操作的等价操作，因为实现中没有用户代码。
- 最终，[[比较-交换操作操作]]就类似于[[memcmp]]使用位比较，而非为 UDT类定义一个比较操作符。如果UDT类型具有对于不同语义的比较操作，或者是这个类型有不参与比较的填充位，那么即使两个对象的值是相等的，
  也可能导致比较-交换操作失败。
- 不要将锁定区域内的数据以引用或指针的形式，作为参数传递给用户提供的函数。通常情况下，编译器不会为 `std::atomic<UDT>` 生成无锁代码，所以所有操作使用一个内部锁。
  id:: 65dda4d3-6c91-495b-a3e1-9795636c9d74
  如果允许用户提供的拷贝赋值或比较操作，就需要传递保护数据的引用作为参数，这就有悖于指导意见了。
  当需要原子操作时，运行库也可使用单锁，并且运行库允许用户提供锁，这样就有可能产生死锁(或因为做一
  个比较操作，而阻塞了其他的线程)。因为这些限制可以让编译器将用户定义的类型当作为一组原始字节，所
  以编译器可以对 `std::atomic<UDT>` 直接使用[[原子指令]](因此实例化一个特殊无锁结构)。
- 如果UDT类型的大小如同(或小于)一个 `int` 或 `void*` 类型时，大多数平台将会对 `std::atomic<UDT>` 使用[[原子指令]]。有些平台可能会对用户自定义类型(两倍于int或 void* 的大小)特化的 `std::atomic<>` 使用原子指令。这些平台通常支持所谓的“双字节比较和交换”([[double-word-compare-and-swap]]，DWCAS)指令，这个指令与 `compare_exchange_xxx` 相关联。指令的支持，对于写无锁代码是有很大的帮助
- 不能使用包含有计数器，标志指针和简单数组的类型，作为特化类型。虽然这不会导致任何问题，但是越是复杂的数据结构，就有越多的操作，而非只有赋值和比较。如果这种情况发生了，最好使用 std::mutex 保护数据。
-