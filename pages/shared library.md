alias:: 共享库

- ## [[静态库]]的缺点
  id:: 65636720-f9e9-46a4-90ec-00bccc6469dc
	- 静态库需要定期 维护 和 更新 。如果应用程序员想要使用一个库的最新版本，他们必须以某种方式了解到该库的更新情况，然后显式地将他们的程序与更新了的库**重新链接**。
	  logseq.order-list-type:: number
	- 几乎每个 C 程序都使用标准 I/O 函数，比如 `printf` 和 `scanf` 。在运行时，这些函数的代码会被复制到每个运行[[进程]]的[[文本段]]中。在一个运行上百个进程的典型系统上，这将是对稀缺的内存系统资源的极大浪费。
	  logseq.order-list-type:: number
	  #+BEGIN_TIP
	  内存的一个有趣属性就是不论系统的内存有多大，它总是一种稀缺资源。磁盘空间和厨房的垃圾桶同样有这种属性。
	  #+END_TIP
- # 共享库
	- [[共享库]]是致力于解决[静态库的缺陷](((65636720-f9e9-46a4-90ec-00bccc6469dc)))。共享库是一个[[目标模块]]，在运行或加载时，可以加载到**任意的**[[内存地址]]，并和一个在内存中的程序链接起来 。这个过程称为[[动态链接]], 是由一个叫做[[动态链接器]]的程序来执行的 。
	- [[共享库]]也称为[[共享目标]], 在[[Linux]]系统中通常用[[.so]]后缀来表示。[[微软]]的操作系统大量地使用了共享库，它们称为[[DLL]]。
	- 共享库是以两种不同的方式来“共享 ＂的。
		- 首先，在任何给定的[[文件系统]]中，对于一个[[共享库]]只有一个[[.so]]文件。所有引用该库的[[可执行目标文件]]共享这个 .so 文件中的 代码 和 数据 ，而不是像静态
		  库的内容那样被复制和嵌入到引用它们
		  的可执行的文件中 。
		  其次，在内存中，
		  一个共享库的 .text 节的一个副本可以
		  被不同的正在运行的进程共享。在第
		  9
		  章我们学习虚拟内存时将更加详细地讨
		  论这个问题。