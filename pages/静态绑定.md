- 在面向对象编程中，静态绑定（Static Binding）和动态绑定（Dynamic Binding）是两种方法，用于决定程序运行时应调用哪个函数或方法。这两种绑定方式的选择关键在于何时决定调用哪个函数——编译时还是运行时。
- ### 静态绑定（Static Binding）
  静态绑定，又称为早期绑定（Early Binding），是在编译时发生的。编译器根据对象的声明类型来确定调用哪个函数。这意味着函数调用是基于对象的类型在编译时就已经确定了。
  **特点**：
	- **性能**：由于编译器已经确定了函数调用的具体地址，因此执行速度快。
	- **限制**：不支持多态，无法在运行时改变函数调用的决定。
- **适用场景**：
	- 函数不需要多态行为。
	- 确定在编译时就能知道调用哪个函数。
- **示例**：在 C++ 中，非虚函数的调用通常是静态绑定的。
  ```cpp
  class Base {
  public:
  void show() {  // 非虚函数
      cout << "Base class show function called." << endl;
  }
  };
  
  class Derived : public Base {
  public:
  void show() {
      cout << "Derived class show function called." << endl;
  }
  };
  
  int main() {
  Base b;
  Derived d;
  Base* ptr = &d;
  ptr->show();  // Calls Base::show()
  }
  ```
- ### 动态绑定（Dynamic Binding）
  动态绑定，也称为晚期绑定（Late Binding），是在运行时发生的。这种类型的绑定允许程序在运行时根据对象的实际类型（而非声明类型）来选择调用哪个函数。
  **特点**：
	- **灵活性**：可以在运行时决定调用哪个方法，支持多态。
	- **开销**：与静态绑定相比，有额外的性能开销，因为需要在运行时查找正确的函数。
- **适用场景**：
	- 需要利用多态性质的情况。
- **示例**：在 C++ 中，通过虚函数实现动态绑定。
  ```cpp
  class Base {
  public:
  virtual void show() {  // 虚函数
      cout << "Base class show function called." << endl;
  }
  };
  
  class Derived : public Base {
  public:
  void show() override {
      cout << "Derived class show function called." << endl;
  }
  };
  
  int main() {
  Base b;
  Derived d;
  Base* ptr = &d;
  ptr->show();  // Calls Derived::show() because of dynamic binding
  }
  ```
  在这个例子中，使用虚函数 `show` 使得通过基类指针 `ptr` 调用 `show` 函数时，实际调用的是 `Derived` 类中的 `show` 方法，这是由于动态绑定使得函数调用解析到运行时。
  总结来说，静态绑定和动态绑定是面向对象编程中函数调用解析的两种机制，选择使用哪一种取决于你对性能和灵活性的需求。
  <!--Converted by ToLogseq-->