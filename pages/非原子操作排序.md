- 通过使用原子操作对非原子操作进行排序，在 happens-before 中的[[sequenced-before]]部分变得非常重要。
  如果一个[[非原子操作]]在一个[[原子操作]]之前被顺序执行，并且那个原子操作在另一个线程中的操作之前发生，那么非原子操作也在另一个线程中的那个操作之前发生。这就是上述清单中对 x 操作排序的来源。
  这也是C++标准库中更高级别同步设施（如互斥锁和条件变量）的基础。
- 为了看到这是如何工作的，考虑简单自旋锁互斥体。
  ``` cpp
  class spinlock_mutex
  {
      std::atomic_flag flag;
  public:
      spinlock_mutex():
      	flag(ATOMIC_FLAG_INIT)
      {}
      void lock()
      {
      	while(flag.test_and_set(std::memory_order_acquire));
      }
      void unlock()
      {
      	flag.clear(std::memory_order_release);
      }
  };
  ```
- `lock()`操作是一个在`flag.test_and_set()`上使用`std::memory_order_acquire`排序的循环，而unlock()是一个带有`std::memory_order_release`排序的`flag.clear()`调用。当第一个线程调用 `lock()` 时，标志最初是清除的，所以第一次调用`test_and_set()`将设置标志并返回 `false`，表明这个线程现在拥有锁，并终止循环。然后线程可以自由修改由互斥体保护的任何数据。此时调用 `lock()` 的任何其他线程都会发现标志已经被设置，并将在`test_and_set()`循环中被阻塞。
- 当拥有锁的线程完成对受保护数据的修改后，它调用 `unlock()` ，这将调用带有`std::memory_order_release`语义的`flag.clear()`。这然后与另一个线程上的 `lock()` 调用中的后续`flag.test_and_set()`调用同步，因为这次调用具有`std::memory_order_acquire`语义。
  因为对受保护数据的修改必然在`unlock()`调用之前被顺序执行，这次修改发生在`unlock()`之前，因此发生在第二个线程的后续`lock()`调用之前（因为`unlock()`和`lock()`之间的同步关系），并且发生在这第二个线程一旦获得锁后对那些数据的任何访问之前。
- 尽管其他[[互斥锁]]实现将具有不同的内部操作，但基本原理是相同的：`lock()`是对内部内存位置的[[获取操作]]，而`unlock()`是对同一内存位置的[[释放操作]]。
- 每种同步机制都将提供关于[[synchronizes-with 关系]]的排序保证。这就是它们能够用于同步你的数据并提供排序保证的原因。以下是这些设施提供的同步关系：
- [[std::thread]]
	- `std::thread`构造函数的完成与在新线程上提供的函数或[[可调用对象]]的调用同步。
	- 线程的完成与对拥有该线程的`std::thread`对象的成功调用[[join]]的返回同步。
- [[std::mutex]]、[[std::timed_mutex]]、[[std::recursive_mutex]]、[[std::recursive_timed_mutex]]
	- 对给定互斥锁对象的所有[[lock]]和[[unlock]]调用，以及对[[try_lock]]、[[try_lock_for]]或[[try_lock_until]]的成功调用，形成一个单一的完整顺序：互斥锁的[[锁定顺序]]。
	- 对给定互斥锁对象的`unlock`调用与该对象在互斥锁的锁定顺序中的后续`lock`调用，或对`try_lock`、`try_lock_for`或`try_lock_until`的后续成功调用同步。
	- 对`try_lock`、`try_lock_for`或`try_lock_until`的失败调用不参与任何同步关系。
- [[std::shared_mutex]]、[[std::shared_timed_mutex]]
	- 对给定互斥锁对象的所有`lock`、`unlock`、`lock_shared`和`unlock_shared`调用，以及对`try_lock`、`try_lock_for`、`try_lock_until`、`try_lock_shared`、`try_lock_shared_for`或`try_lock_shared_until`的成功调用，形成一个单一的完整顺序：互斥锁的[[锁定顺序]]。
	- 对给定互斥锁对象的`unlock`调用与该对象在互斥锁的锁定顺序中的后续`lock`或`shared_lock`调用，或对`try_lock`、`try_lock_for`、`try_lock_until`、`try_lock_shared`、`try_lock_shared_for`或`try_lock_shared_until`的成功调用同步。
	- 对`try_lock`、`try_lock_for`、`try_lock_until`、`try_lock_shared`、`try_lock_shared_for`或`try_lock_shared_until`的失败调用不参与任何同步关系。
- [[std::promise]]、[[std::future]]和[[std::shared_future]]
	- 对给定`std::promise`对象的[[set_value]]或[[set_exception]]的成功完成与从对[[wait]]或[[get]]的调用成功返回，或对[[wait_for]]或[[wait_until]]的调用返回[[std::future_status::ready]]的成功返回同步，该 `future` 与 `promise` 共享相同的[[异步状态]]。
	- 给定`std::promise`对象的析构函数，在与promise关联的共享异步状态中存储`std::future_error`异常，与从对`wait`或`get`的调用成功返回，或对`wait_for`或`wait_until`的调用返回`std::future_status::ready`的成功返回同步，该future与promise共享相同的异步状态。
- [[std::packaged_task]]、`std::future`和`std::shared_future`
	- 对给定`std::packaged_task`对象的函数调用操作符的成功完成与从对`wait`或`get`的调用成功返回，或对`wait_for`或`wait_until`的调用返回`std::future_status::ready`的成功返回同步，该future与packaged task共享相同的异步状态。
	- 给定`std::packaged_task`对象的析构函数，在与packaged task关联的共享异步状态中存储`std::future_error`异常，与从对`wait`或`get`的调用成功返回，或对`wait_for`或`wait_until`的调用返回`std::future_status::ready`的成功返回同步，该future与packaged task共享相同的异步状态。
- [[std::async]]、`std::future`和`std::shared_future`
	- 通过对`std::async`的调用以`std::launch::async`策略启动任务的线程完成，与从对`wait`或`get`的调用成功返回，或对`wait_for`或`wait_until`的调用返回[[std::future_status::ready]]的成功返回同步，该 `future` 与启动的任务共享相同的[[异步状态]]。
	- 通过对`std::async`的调用以[[std::launch::deferred]]策略启动的任务完成，与从对`wait`或`get`的调用成功返回，或对`wait_for`或`wait_until`的调用返回`std::future_status::ready`的成功返回 同步，该 `future` 与`promise` 共享相同的[[异步状态]]。
- `std::experimental::future`、`std::experimental::shared_future`和延续
	- 导致异步共享状态变为就绪的事件与在该共享状态上调度的延续函数的调用同步。
	- 延续函数的完成与从对`wait`或`get`的调用成功返回，或对`wait_for`或`wait_until`的调用返回`std::future_status::ready`的成功返回同步，该future与从调用`then`返回的future共享相同的异步状态，该调用安排了延续，或在该future上调度的任何延续的调用。
- `std::experimental::latch`
	- 对给定实例的`std::experimental::latch`的每次调用`count_down`或`count_down_and_wait`与在该latch上的每次成功调用`wait`或`count_down_and_wait`的完成同步。
- `std::experimental::barrier`
	- 对给定实例的`std::experimental::barrier`的每次调用`arrive_and_wait`或`arrive_and_drop`与在该barrier上的每次后续成功调用`arrive_and_wait`的完成同步。
- `std::experimental::flex_barrier`
	- 对给定实例的`std::experimental::flex_barrier`的每次调用`arrive_and_wait`或`arrive_and_drop`与在该barrier上的每次后续成功调用`arrive_and_wait`的完成同步。
	- 对给定实例的`std::experimental::flex_barrier`的每次调用`arrive_and_wait`或`arrive_and_drop`与在该barrier上的后续完成函数的调用同步。
	- 在给定实例的`std::experimental::flex_barrier`上的完成函数返回与在该barrier上的每次调用`arrive_and_wait`的完成同步，该调用在完成函数被调用时被阻塞等待该barrier。
- [[std::condition_variable]]和[[std::condition_variable_any]]
	- 条件变量**不提供任何同步关系**。它们是**对[[忙等循环]]的优化**，所有的同步都是由关联的[[互斥锁]]上的操作提供的。
-