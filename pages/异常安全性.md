alias:: 异常安全, exception safety

- 在编程中，**异常安全性**（Exception Safety）指的是当程序执行中抛出[[异常]]时，代码能够正确处理异常，确保程序的整体状态依然是一致和有效的。在C++中，异常安全性尤其重要，因为语言提供了丰富的异常处理能力，而管理资源（如动态内存、文件句柄、网络连接等）需要特别注意。
- 异常安全性通常分为几个级别，由低到高分别是：
	- **无保证（No Guarantee）**：当异常发生时，程序可能处于破坏状态，资源可能泄露，对象可能处于未定义状态。
	  logseq.order-list-type:: number
	- **基本保证（Basic Guarantee）**：这也被称为“提交或回滚”语义。即使发生异常，程序的整体状态仍然保持一致，不会泄露资源，对象虽然可能不保持原有状态，但仍保持有效状态。这意味着任何操作要么完全成功，要么在遇到错误时回滚到操作前的状态。
	  logseq.order-list-type:: number
	- **强保证（Strong Guarantee）**：操作可以视为原子操作，要么完全成功，要么在异常发生时使程序状态保持不变，如同没有执行过该操作一样。这要求操作在执行任何修改前，先行保证成功的可能，或者在失败时完全恢复到初始状态。
	  logseq.order-list-type:: number
	- **无异常保证（Nothrow Guarantee）**：保证代码绝不抛出异常。这通常适用于某些特定函数，特别是那些不涉及任何形式资源分配或只使用不抛出异常的操作的函数。
	  logseq.order-list-type:: number
- ### 在C++中实现异常安全性
  实现异常安全性的关键是正确使用C++的资源管理特性，例如：
	- **智能指针**（如 `std::unique_ptr` 和 `std::shared_ptr`）自动管理内存，帮助防止内存泄露。
	- **资源获取即初始化（RAII）**模式：通过对象的构造函数获取资源，并在析构函数中释放资源，确保即使发生异常，资源也能被正确释放。
	- **异常安全的函数**：设计函数时，考虑到在函数执行过程中可能抛出异常的地方，确保所有场景下资源都得到妥善管理。
	- **复制交换技术**（ [[copy-and-swap]] idiom）：这是实现强异常保证的一种技术，特别适用于赋值操作。通过先在局部变量上构造新状态，然后通过交换操作原子地替换旧状态，可以在出错时保持对象状态不变。
- ### 示例
  考虑一个简单的类，管理一个动态分配的数组：
  ```cpp
  #include <algorithm>  // std::copy
  #include <cstddef>    // std::size_t
  
  class SimpleArray {
  public:
    SimpleArray(std::size_t size) : size_(size), array_(new int[size]) {}
  
    ~SimpleArray() {
        delete[] array_;
    }
  
    // Copy constructor (Strong Guarantee)
    SimpleArray(const SimpleArray& other) : size_(other.size_), array_(new int[other.size_]) {
        std::copy(other.array_, other.array_ + size_, array_);
    }
  
    // Copy assignment operator (Strong Guarantee)
    SimpleArray& operator=(const SimpleArray other) {
        swap(*this, other);
        return *this;
    }
  
    friend void swap(SimpleArray& first, SimpleArray& second) {
        using std::swap;
        swap(first.size_, second.size_);
        swap(first.array_, second.array_);
    }
  
  private:
    std::size_t size_;
    int* array_;
  };
  ```
  
  这个类使用RAII和复制交换技术，即使在构造函数或赋值操作过程中发生异常，也能保证资源被安全管理。通过这种方式，`SimpleArray` 类实现了强异常保证。
  <!--Converted by ToLogseq-->
- ## [[返回值的异常安全性]]
	- 在 C++ 等编程语言中，当函数通过值返回一个对象时，涉及到对象的复制或移动。如果这个对象的复制构造函数或移动构造函数抛出异常（例如，因为[[内存分配失败]]），那么几件事情会同时发生：
		- **异常抛出**：当函数尝试返回对象时，复制或移动构造函数中的异常将被抛出。
		- **函数终止**：由于异常，函数会提前终止，不会完成到达返回点后的正常执行路径。
		- **数据丢失**：因为异常的抛出，原本应该被返回的对象无法成功构造，从而导致预期外的数据丢失。
	- ### 确保返回值异常安全的方法
	  在处理函数的返回值时，如果返回过程中抛出异常，可能会导致复杂的问题，例如资源泄露或状态不一致。以下是一些确保返回值异常安全性的方法：
		- 1. **使用智能指针**：如 `std::unique_ptr` 或 `std::shared_ptr`，这些智能指针可以自动管理内存，即使在函数抛出异常时也能保证适当的资源释放。
		- 2. **返回值优化**（Return Value Optimization, RVO）和**命名返回值优化**（Named Return Value Optimization, NRVO）：这是编译器的优化技术，可以减少或消除返回对象时的复制和移动操作，从而降低抛出异常的风险。
		- 3. **使用标准容器和异常安全类型**：如 `std::vector`、`std::string` 等，这些类型在设计时考虑了异常安全性，通常提供强异常保证。
		- 4. **谨慎使用异常规范**：使用 `noexcept` 关键字明确标记不抛出异常的函数，以提供更强的安全保障和可能的性能优化。
- ### 示例
  考虑一个函数，它创建并返回一个复杂对象的实例：
  
  ```cpp
  MyClass createMyClass() {
    MyClass obj;
    // 进行一些可能抛出异常的操作
    return obj;
  }
  ```
  
  在这个示例中，如果在构造 `MyClass` 或操作过程中抛出异常，由于局部对象 `obj` 的生命周期，它会被自动销毁，从而防止资源泄露。如果使用了C++17或更高版本，编译器还会利用返回值优化来避免复制或移动操作，进一步增强异常安全性。
-