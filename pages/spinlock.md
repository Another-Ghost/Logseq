alias:: 自旋锁

- 自旋锁（Spinlock）是一种在多线程环境下用于保护共享资源的低开销同步机制。与传统的互斥锁（如`std::mutex`）相比，自旋锁在等待锁释放时，会让线程处于忙等（busy-wait）状态，即不断循环检查锁的状态，直到锁变为可用状态。这种机制避免了[[线程的上下文切换]]开销，但会消耗CPU时间，因此**更适合于等待时间非常短的场景**。
- ### 特点
	- **忙等待**：线程不断检查锁的状态，而不是睡眠等待，这样可以在锁被释放的瞬间立即获取锁，减少等待时间。
	- **CPU消耗**：由于忙等待，CPU会持续工作以检查锁状态，这在长时间等待锁的情况下会导致CPU资源浪费。
	- **短时间优势**：对于那些只需要很短时间就能完成的锁定操作，使用自旋锁可以减少线程切换的开销，提高效率。
	- **无上下文切换**：由于线程不进入睡眠状态，因此使用自旋锁不会引起线程上下文切换。
- ### 使用场景
	- 锁持有时间非常短；
	- 系统中有足够的CPU资源，可以承受忙等的CPU消耗；
	- 高性能计算或实时系统，其中线程切换的延迟是不可接受的。
- ### 实现方式
  在C++中，可以通过[[std::atomic_flag]]或[[std::atomic]]等原子操作来实现自旋锁。以下是使用`std::atomic_flag`实现的自旋锁简单示例：
  ```cpp
  #include <atomic>
  #include <thread>
  
  class Spinlock {
  public:
    void lock() {
        while (lock_flag.test_and_set(std::memory_order_acquire)) {
            // 忙等待，直到锁被释放
        }
    }
  
    void unlock() {
        lock_flag.clear(std::memory_order_release);
    }
  
  private:
    std::atomic_flag lock_flag = ATOMIC_FLAG_INIT;
  };
  ```
- ### 注意事项
	- 自旋锁适合于锁持有时间短且对响应时间要求高的场景。如果锁持有时间长，或者不确定，使用传统的互斥锁可能更合适，以避免过度消耗 CPU 资源。
	- 在单核处理器上使用自旋锁可能会导致性能问题，因为忙等待的线程占用了处理器时间，可能阻塞了需要运行的其他线程，包括可能释放锁的线程。
	- 在设计并发控制时，应仔细选择合适的同步机制，以平衡性能和资源消耗。
-