- 为了避免条件竞争，线程就要以一定的顺序执行。
	- 第一种方式，使用[[互斥量]]来确定访问的顺序。当同一互斥量在两个线程同时访问前锁住，那么在同一时间内就只有一个线程能够访问对应的内存位置。
	- 另一种是使用[[原子操作]]决定两个线程的访问顺序，当多个线程访问同一个内存地址时，对每个访问者都需要设定顺序。
	  如果不规定对同一内存地址访问的顺序，那么访问就不是原子的。当两个线程都是“写入者”时，就会产生数据竞争和未定义行为。
- 另一个重点是：当程序对同一内存地址中的数据访问存在竞争，可以使用原子操作来避免未定义行为。当
  然，这不会影响竞争的产生——原子操作并没有指定访问顺序——而原子操作会把程序拉回到定义行为的区
  域内。
- C++程序中的对象都有(由程序中的所有[[线程对象]])在初始化开始阶段确定好 *修改顺序* 的。
  id:: 65db7ccd-36bd-4091-9a8d-96ba76c48e4d
  大多数情况下，这个顺序不同于执行中的顺序，但在给定的程序中，所有线程都需要遵守这个顺序。
  如果对象不是[[原子类型]]，必须确保有足够的[[同步操作]]，确定线程都遵守了 *修改顺序* 。
  当不同线程在不同序列中访问同一个值时，可能就会遇到数据竞争或未定义行为。
  如果使用[[原子操作]]，[[编译器]]就有责任去做同步。
- 这个要求意味着某些类型的 推测执行 是不允许的，因为一旦线程观察到 *修改顺序* 中的特定条目，之后的 读操作 必须由线程返回新值，并且之后的 写操作 必须发生在 修改顺序 之后。
  虽然，所有线程都需要遵守程序中 每个独立对象的修改顺序 ，但没有必要遵守在不同对象上的相对操作顺序。