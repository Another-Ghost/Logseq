- 共享库的一个主要目的就是允许多个正在运行的进程共享内存中相同的库代码，因而节约宝贵的内存资源。那么，多个进程 是如何共享程序的一个副本的呢？一 种方法 是给每个共享库分配一个事先预备的专用的地址空间片，然后要求加载器总是在这个地址加载共享库。虽然这种方法很简单，但是它也造成了一些严重的问题。它对地址空间的使用效率不高，因为即使一个进程不使用这个库，那部分空间还是会被分配出来。它也难以管理。我们必须保证没有片会重叠。每次当一个库修改了之后，我们必须确认已分配给它的片还适合它的大小。如果不适合了，必须找一个新的片。并且，如果创建了一个新的库，我们还必须为它寻找空间。随着时间的进展，假设在一个系统中有了成百个库和库的各个版本库，就很难避免地址空间分裂成大量小的、未使 用而又不 再能使用的小洞。更糟的是，对每个系统而 言，库在内存中的分配都是不同的，这就引起了更多令人头痛的管理问题。要避免这些问题，现代系统以这 样一种方式编译共享模块的代码段，使得 可以把它们加载到内存的任何位置 而无需 链接器修改。使用这 种方法，无限 多个进程 可以共 享一个共享模块的代码段的单一副本。（当然，每个进程仍然会有它自己的读／写数据块。）可以加载而无需 重定位的代码称为位置无关代码(Position Ind epe ndent Code, PIC)。用户对 GCC使用-fpic选项指示 GNU编译系统生成 PIC代码。共享 库的编译必须总是使用该选项。在一个 x86-64系统 中，对同一个目标模块中符号的引用是不 需要特殊 处理使之成为 PIC。可以用 PC相对寻址来编译这些引用，构造目标文件时由静态链接器重定位。然而，对共享模块定义的外部过程和对全局变 量 的引用需要一些特殊的技巧，接下来我们会谈到。
- TODO 链接
  SCHEDULED: <2023-11-27 Mon>
  :LOGBOOK:
  
  :END: