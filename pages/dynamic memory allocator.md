alias:: 动态内存分配器, 分配器

- [[动态内存分配器]]**维护**着一个进程的[[虚拟内存区域]]，称为[[堆]]。
	- 系统之间细节不同，但是不失通用性，假设 堆 是一个[[请求二进制零的区域]]，它紧接在[[未初始化的数据区域]]后开始，并向上生长（向**更高的**地址）。
	- 对于每个 进程 ，[[内核]]维护着一个变量[[brk]](读做"break"),它指向 堆的顶部 。
	- ![image.png](../assets/image_1702064189044_0.png)
- [[分配器]]将堆视为一组不同大小的[[块]]的集合来维护。
  每个[[块]]就是一个连续的[[虚拟内存片]], 要么是[[已分配块]]，要么是[[空闲块]]。
	- [[已分配块]]显式地保留为供[[应用程序]]使用。
	- [[空闲块]]可用来分配。空闲块保持空闲，直到它显式地被应用所[[分配]]。
- 一个[[已分配的块]]保持已分配状态，直到它被[[释放]]，这种释放要么是[[应用程序]] *显式执行* 的，要么是[[内存分配器]]自身 *隐式执行* 的。
- 分配器有两种基本风格。两种风格都要求应用 *显式地* 分配块。它们的不同之处在于由哪个[[实体]]来负责[[释放]]已分配的块。
	- [[显式分配器]]
		- 要求应用 *显式地释放* 任何已分配的块。
		- 例如，C标准库 提供一种叫做[[malloc 程序包]]的[[显式分配器]]。 C程序通过调用[[malloc]]函数来．分配一个块，并通过调用[[free]]函数来释放一个块。 C++中的`new`和`delete`操作符与 C中的`malloc`和`free`相当。
	- [[隐式分配器]]
		- 要求[[分配器]]检测一个[[已分配块]]何时不再被程序所使用，那么就释放这个块。隐式分配器也叫做[[垃圾收集器]](garbage collector), 而自动释放 *未使用的已分配的块* 的过程叫做[[垃圾收集]](garbage collection)。
		- 例如，诸如 Lisp、 ML 以及 Java 之类的高级语言就依赖垃圾收集来释放已分配的块。
- # 分配器的要求和目标
	- [[显式分配器]]必须在一些相当严格的约束条件下工作：
		- 处理任意请求序列。
		  logseq.order-list-type:: number
			- 一个应用可以有任意的分配请求和释放请求序列，只要满足约束条件：每个释放请求必须对应于一个当前已分配块，这个块是由一个以前的分配请求获得的。因此，分配器不可以假设分配和释放请求的顺序。例如，分配器不能假设所有的分配请求都有相匹配的释放请求，或者有相匹配的分配和空闲请求是嵌套的。
		- 立即响应请求。
		  logseq.order-list-type:: number
			- 分配器必须立即响应分配请求。因此，**不允许**分配器为了提高性能**重新排列**或者**缓冲请求**。
		- 只使用堆。为了使分配器是可扩展的，分配器使用的任何非标量数据结构都必须保存在堆里。
		  logseq.order-list-type:: number
		- 对齐块（对齐要求）。分配器必须对齐块，使得它们可以保存任何类型的数据对象。
		  logseq.order-list-type:: number
		- 不修改已分配的块。分配器只能操作或者改变空闲块。特别是，一旦块被分配了，就不允许修改或者移动它了。因此，诸如压缩已分配块这样的技术是不允许使用的。
		  logseq.order-list-type:: number
	-