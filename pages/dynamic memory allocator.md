alias:: 动态内存分配器, 分配器

- [[动态内存分配器]]**维护**着一个进程的[[虚拟内存区域]]，称为[[堆]]。
	- 系统之间细节不同，但是不失通用性，假设 堆 是一个[[请求二进制零的区域]]，它紧接在[[未初始化的数据区域]]后开始，并向上生长（向**更高的**地址）。
	- 对于每个 进程 ，[[内核]]维护着一个变量[[brk]](读做"break"),它指向 堆的顶部 。
	- ![image.png](../assets/image_1702064189044_0.png)
- [[分配器]]将堆视为一组不同大小的[[块]]的集合来维护。
  每个[[块]]就是一个连续的[[虚拟内存片]], 要么是[[已分配块]]，要么是[[空闲块]]。
	- [[已分配块]]显式地保留为供[[应用程序]]使用。
	- [[空闲块]]可用来分配。空闲块保持空闲，直到它显式地被应用所[[分配]]。
- 一个[[已分配的块]]保持已分配状态，直到它被[[释放]]，这种释放要么是[[应用程序]] *显式执行* 的，要么是[[内存分配器]]自身 *隐式执行* 的。
- 分配器有两种基本风格。两种风格都要求应用 *显式地* 分配块。它们的不同之处在于由哪个[[实体]]来负责[[释放]]已分配的块。
	- [[显式分配器]]
		- 要求应用 *显式地释放* 任何已分配的块。
		  例如，C标准库 提供一种叫做[[malloc 程序包]]的[[显式分配器]]。 C程序通过调用`malloc`函数来．分配一个块，并通过调用`free`函数来释放一个块。 C++中的 new和 delete操作符与 C中的 malloc和 free相当。•隐式分配器(implicit allocator),另一方面，要求分配器检测一个已分配块何时不再被程序所使用，那么就释放这个块。隐式分配器也叫做垃圾收集器(garbage collector),而自动释放未使用的已分配的块的过程叫做垃圾收集(garbage collection)。例如，诸如 Lisp、 ML以及 J a v a之类的高级语言就依赖垃圾收集来释放已分配的块。