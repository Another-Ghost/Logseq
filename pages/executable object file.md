alias:: 可执行目标文件, .prog, executable file

- #Linux
- [[可执行目标文件]]包含二进制代码和数据，其形式可以被直接复制到[[内存]]并执行。
- 下图概括了一个典型的[[ELF 可执行文件]]中的各类信息：
  ![image.png](../assets/image_1697895229975_0.png)
- 可执行目标文件的格式类似于[[可重定位目标文件]]的格式。
- [[ELF 头]]描述文件的总体格式。
  id:: 6533d627-b943-4717-9c4a-88bbf651abfd
  它还包括程序的[[entry point]], 也就是当程序运行时要执行的第一条指令的地址。
- [[.text]]、[[.rodata]]和[[.data]]节与可重定位目标文件中的节是相似的，除了这些节**已经**被
  [[重定位]]到它们最终的运行时内存地址以外。
- [[.init]]节定义了一个小函数，叫做[[_init]]，程序的 *初始化代码* 会调用它。因为可执行文件是 *完全链接* 的（已被重定位）， 所以它不再需要[[.rel]]节。
- ELF 可执行文件被设计得很容易加载到[[内存]]，可执行文件的连续的[[chunk]]被映射
  到连续的[[内存段]]。[[program header table]]描述了这种映射关系。下图展示
  了可执行文件`prog`的程序头部表，是由[[OBJDUMP]]显示的。
  ![image.png](../assets/image_1697897288714_0.png)
  `off`：目标文件中的偏移；
  `vaddr/paddr`: 内存地址； 
  `align`: 对齐要求；
  `filesz`: 目标文件中的段大小；
  `memsz`：内存中的段大小；
  `flags`: 运行时访问权限。
- 从程序头部表，我们会看到根据可执行目标文件的内容初始化两个[[内存段]]。第 1 行和第 2 行告诉我们第一个段（代码段）有读/执行访问权限，开始于内存地址 〇x400(300 处，总
  id:: 6533dcc5-c465-4f0b-a203-8cb9ea1cb0da
  共的内存大小是 0x69c 字节，并且被初始化为可执行目标文件的头 0x69c 个字节，其中包
  括 ELF 头、程序头部表以及 .initÿ .text 和 .rodata 节。
  第 3 行和第 4 行告诉我们第二个段（数 据段）有读/写访问权限，开始于内存地址
  0x600df8 处，总的内存 大小为 0x230 字节，并用从目标文件中偏移 0xdf8 处 开始的
  .data节中的 0x228 个字节初始化。该段中剩下的 8 个字节对应于运行时将被初始化为 0
  的 .bss 数据。
  对于任何段 sÿ 链接器必须选择一个起始地址 vaddr, 使得
  vaddr mod align = off mod align
  这里，off 是目标文件中段的第一个节的偏移量，align 是程序头部中指定的对齐(221_ =
  OdOOQQ.CJh 例如，图 7-14 中的数据段中
  vaddr mod align = 0x600df8 mod 0x200000 = Oxdf8
  以及
  off mod align = Oxdf8 mod 0x200000 — Oxdf8
  这个对齐要求是一种优化，使得当程序执行时，目标文件中的段能够很有效率地传送到内
  存中。原因有点儿微妙，在于虚拟内存的组织方式，它被组织成一些很大的、连续的、大
  小为 2 的幂的字节片。第 9 章中你会学习到虚拟内存的知识。
- # 加载可执行目标文件
	- 要运行可执行目标文件`prog`, 我们可以在 Linux shell 的命令行中输入它的名字：
	- ``` shell
	  linux> ./prog
	  ```
	- shell 会认为 prog 是一个可执行目标文件，通过调用某个驻留在存储器中称为[[加载器]]的操作系统代码来运行它。任何Linux 程序都可以通过调用
	  个函数。加载器将可执行目标文件中的代码和数据从磁盘复制到内存中，然后通过跳转到程
	  序的第一条指令或入口点来运行该程序。这个将程序复制到内存并运行的过程叫做加栽。
	  每个 Linux 程序都有一个运行时内存映像，类似于图 7-15 中所示。在 Linux X86-64
	  系统中，代码段总是从地址 0x400加0 处开始，后面是数据段。运行时堆在数据段之后，
	  通过调用 malloc 库往上增长。（我们将在 9.9 节中详细描述 mallDc 和堆。）堆后面的区域
	  是为共享模块保留的。用户栈总是从最大的合法用户地址（248 —1)开始，向较小内存地址
	  增长。栈上的区域，从地址 248 开始，是为内核（kernel)中的代码和数据保留的，所谓内核
	  就是操作系统驻留在内存的部分。
	  为了简洁，我们把堆、数据和代码段画得彼此相邻，并且把栈顶放在了最大的合法用
	  户地址处。实际上，由于 .data 段有对齐要求(见 7.8 节）， 所以代码段和数据段之间是有
	  间隙的。同时，在分配栈、共享库和堆段运行时地址的时候，链接器还会使用地址空间布
	  局随机化(ASLRÿ 参见 3.10.4 节）。 虽然每次程序运行时这些区域的地址都会改变，它们
	  的相对位置是不变的。
	  当加载器运行时，它创建类 似于图 7-15 所示的内存映像。在程序头部表的引导下,
	  加载器将可执行文件的片(chunk)复制到代码段和数据段。接下来，加载器跳转到程序的