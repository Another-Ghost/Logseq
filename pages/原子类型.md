- 原子类型在多线程编程中用于保证对共享数据的线程安全访问，无需使用互斥锁。通过原子类型，编程语言提供了一种机制，以原子方式执行对共享数据的读取、写入和更新操作，从而避免了数据竞争和其他并发问题。
- ### C++中的原子类型
  C++11 引入了`<atomic>`头文件，提供了一系列原子类型和操作，使得在多线程环境中对基本数据类型进行操作成为可能。这些原子类型包括：
	- **基本原子类型**：`std::atomic_bool`、`std::atomic_char`、`std::atomic_int`等，为基本数据类型提供原子操作。
	- [[原子指针类型]]：`std::atomic<T*>`，允许对指针进行原子操作。
	- **特殊原子类型**： [[std::atomic_flag]]，是一个布尔标志，可以原子地设置和清除。它是实现自旋锁等同步机制的基础。
- ### 原子操作
  对原子类型的操作不会被线程调度中断，它们包括：
- **加载（Load）**：原子地读取变量的值。
- **存储（Store）**：原子地写入变量的值。
- **修改操作**：如原子地递增（`++`）、递减（`--`）、加法（`+=`）、减法（`-=`）等。
- **[[比较并交换]]**：如果当前值等于期望值，则将变量设置为新值。
- ### 内存顺序
  C++中的原子操作还允许指定内存顺序，这影响了操作的可见性和顺序。常见的内存顺序包括：
	- **顺序一致性（`std::memory_order_seq_cst`）**：默认的最强内存顺序保证，所有线程看到相同的操作顺序。
	- **放宽（`std::memory_order_relaxed`）**：只保证原子性，不保证操作间的顺序。
	- **获取（`std::memory_order_acquire`）**和**释放（`std::memory_order_release`）**：用于控制操作间的依赖关系，防止重排序。
- ### 使用示例
  
  ```cpp
  #include <atomic>
  #include <iostream>
  #include <thread>
  
  std::atomic<int> count(0); // 定义原子变量
  
  void increment() {
    for (int i = 0; i < 10000; ++i) {
        count.fetch_add(1, std::memory_order_relaxed); // 原子递增
    }
  }
  
  int main() {
    std::thread t1(increment);
    std::thread t2(increment);
  
    t1.join();
    t2.join();
  
    std::cout << "Count: " << count.load(std::memory_order_relaxed) << std::endl;
    return 0;
  }
  ```
- ### 注意事项
	- 使用原子类型可以避免锁的开销，但它们不是万能的。在高度竞争的环境下，频繁的原子操作仍然可能成为性能瓶颈。
	- 正确选择内存顺序对于保证程序的正确性和性能至关重要。在不影响程序逻辑的前提下，选择适当的内存顺序可以提升性能。