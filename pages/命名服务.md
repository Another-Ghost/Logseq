alias:: naming service

- ## 定义
	- [[服务端进程]]可以将自己提供的服务告诉 命名服务进程 ，比如文件系统进程可以注册一个“文件系统服务”，网络系统进程可以注册一个“网络服务”。
	  而[[客户端进程]]可以在命名服务中查询当前服务，并选择自己希望建立连接的服务去尝试获取权限。
	  具体是否 分发权限 给客户端进程，是由^^命名服务^^和^^对应的服务端进程^^根据特定的策略来判断的。
	- 比如，文件系统进程的策略可能是，允许命名服务将连接文件系统的权限任意分发，这样所有的进程都可以使用全局的文件系统。
	  而数据库进程的策略是，客户端必须提供特定私钥签名的证书，并且证书符合数据库进程的要求，才能完成建立。
- 使用命名服务有很多好处，比如各个服务不再是内核中的 ID 等抽象的表示，而是对应用更友好的“名字”。[[服务发现]]通常就是使用命名服务来实现的。
- #+BEGIN_TIP
  为什么命名服务一般在用户态？
  从上面的介绍中可以看到命名服务的功能其实并不简单，并且通常需要支持很多不同的策略。将这些策略实现在内核中，对于微内核系统显然是不合适的。而即使是宏内核系统，这也不是一种优雅的设计。举例来看，宏内核的AndroidBinder、ROS以及微内核的L4等，都是依赖（用户态的）命名服务来完成连接权限分发的。当然，在具体的设计细节上，它们仍然存在很多的不同。
  #+END_TIP
- 除了命名服务外，另外一种常见的方式是通过继承来分发连接权限。比如在Linux中，匿名管道通常用于父子进程之间的通信，内核通过在fork操作的时候复制文件描述符表来建立父子进程间的连接。微内核系统在创建新的线程/进程时，内核通常也允许父进程将特定的Capability直接继承给子进程。这种继承的方式对于一些不希望暴露到全局的通信连接来说是一个保密性更好的方式，不过它的适用场景相对也比较有限。