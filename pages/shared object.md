alias:: 共享目标

- #+BEGIN_TIP
  正如我们看到的，进程 这一抽象能够为每个进程提供自己私有的虚拟地址空间，可以免受其他进程的错误读写。
  不过，许多进程有**相同的只读代码区域**。例如，每个运行 Linux shell 程序 bash 的进程都有相同的代码区域。而且，许多程序需要访问[[只读运行时库]]代码的**相同副本**。例如，每个 C程序 都需要来自 标准C库 的诸如 `printf` 这样的函数。
  那么，如果每个进程都在 物理内存 中保持这些常用代码的副本，那就是极端的浪费了。幸运的是，[[内存映射]]给我们提供了一种清晰的机制，用来控制多个[[进程]]如何[[共享目标]]。
  #+END_TIP
- 一个[[目标]]可以被[映射]([[内存映射]])到[[虚拟内存]]的一个[区域]([[虚拟内存区域]])，要么作为[[共享目标]]，要么作为[[私有目标]]。
	- 如果一个进程将一个[[共享目标]]映射到它的虚拟地址空间的一个 *区域* 内，那么这个进程对这个 区域 的任何写操作，对于那些也把这个[[共享目标]]映射到它们虚拟内存的 其他进程 而言，也是[[可见的]]。
	  而且，这些变化也会反映在[[磁盘]]上的[[原始目标]]中。
	- 另一方面，对于一个映射到[[私有目标]]的 *区域* 做的改变，对于 其他进程 来说是[[不可见的]]，并且进程对这个区域所做的任何 写操作 都**不会**反映在 *磁盘* 上的 *原始目标* 中。
- 一个映射到[[共享目标]]的[[虚拟内存区域]]叫做[[共享区域]]。类似地，也有[[私有区域]]。