- 某些类型的错误与并发的使用直接关联。通常，这些与并发关联的错误分为两大类型。
- ## 多余的[[阻塞]]
	- 虽然阻塞是多线程程序的自然组成部分，但代码并非总是编写得当， 结果导致多余的阻塞。
	- 若一个线程被阻塞，而别的线程又在等待该线程执行某项操作，则后面的等待线程也被迫阻 塞。
	- 上述情形有几种变化。
	- ### [[死锁]]
	- ### [[活锁]]
	- ### [[IO 阻塞]]或其他[[外部阻塞]]
		- 若线程因等待外部输入而阻塞，就会停滞不前;若所等 的输入一直未抵达，则该线程更是原地踏步。因此，如果 一个线程正等待着另一个线程 完成任务，则后者不应该因外部输人而阻塞。
- ## [[条件竞争]]
	- 多线程代码中，条件竞争是各种问题的最常见诱因之一，许多[[死锁]]和[[活锁]]只是条件竞争的表现形式。并非所有条件竞争都屈于^^恶性竞争^^。
	- 当多个独立线程因调度导致相对次序有异，而其上的操作的**具体行为又取决于这种相对次序差异**，条件竞争才会出现。
	- 多数条件竞争属于完全良性。
	  例如，就[[任务队列]]而言，由哪个工作线程执行下 一项任务根本无关紧要。
	  然而，许多并发问题的诱因还是条件竞争。条件竞争经常造成的问题类型如下。
	- ### [[数据竞争]]
		- 这是一种特别的[[条件竞争]]。它的起因是对[[共享内存区域]]的并发访问未采取同步措施，结果导致未定义行为。
		  数据竞争的成因通常是为了同步线程而错误使用[[原子操作]]， 或没有恰当地锁住互斥而访问共享数据。
	- ### 受到破坏的[[不变量]]
		- 其表现形式为
			- [[悬空指针]]（当前线程正在通过指针访问目标数据，而其他线程却同时删除指针）、
			- 随机的[[内存数据损坏]](数据正更新到 一半， 而其他线程却同时读取，造成数据不一致)、
			- [[重复释放内存]](double-free，两个线程同时从队列弹出相同的值，它们都删除某份关联的数据)等。
		- 不变量的破坏与时间相关，也与程序中的值相关。若多个线程上的多个操作需要按特定次 序执行，有时候错误的同步方式会**破坏特定次序**而导致条件竞争。
	- ### [[生存期问题]]
		- 尽管这类问题可以划归为[[不变量]]被破坏，但我们将其作为一独立 分类。这类错误中最基本的问题是，**^^线程的生存期^^超出了它所访问的数据的生存期**。数据被删除或以其他方式销毁后，线程仍试图访问它们，而相应的存储空间有可能已被另一个对象重用。
		- 出现生存期问题的情形往往是，局部变量的引用在线程函数结束前传到函数外部，让线程在作用范围以外访问失效或销毁的变量。但产生问题的情形不止这一种。即便线程的生命期和它所操作的目标数据无关，数据还是有可能在线程结束之前销毁，令线程函数脱离正轨。
		- 若我们手动调用 `join` 以等待线程结束，就要保证 `join()` 的调用不会因出现异常而跳过。这是异常安全最基本的要求，多线程代码都适用。
	- 条件竞争有时是致命的。无论发生死锁还是活锁，应用软件都会像处于挂起状态一 样，完全没有响应，或用很长时间才能完成任务。
	- 通常，若多线程程序发生了死锁或活锁，我们可以在其所属的进程附着运行调试工具，以确定这些线程在哪些同步对象上发生纠缠。
	  数据竞争、受到破坏的不变量和生存期问题都将产生可见的后果(形式为**无规律崩溃**、**错误的输出**，它们会在代码的任何部分造成问题。
	  代码可能改写其他系统组件正在使用的内存，而很久后才会访问改写的地方。出现的向题可能与造成错误的代码毫无关联，并且可能在程序运行很长时间后才暴露。这对**共享内存系统**而言，简直是致命的。无论我们如何尽力限制哪个线程访问什么数据，如何正确地实施同步保障，在同一应用程序内，任一线程都可以改写另一线程。
-