alias:: 共享状态

- 共享状态（Shared State）是多线程或并发编程中的一个核心概念，指的是由多个[[线程]]或任务共同访问和操作的数据或状态。正确管理共享状态对于保证程序的正确性和性能至关重要。不当的共享状态管理可能导致数据竞争（Data Race）、死锁（Deadlock）和其他同步问题，影响程序的稳定性和效率。
- ### 管理共享状态的机制
  
  在C++中，有多种机制可用于安全地管理共享状态，包括：
  
  1. **互斥锁（Mutexes）**：
	- `std::mutex`、`std::recursive_mutex`、`std::timed_mutex` 等，用于保护共享数据，确保同一时间只有一个线程可以访问共享状态。
	  
	  2. **条件变量（Condition Variables）**：
	- `std::condition_variable` 和 `std::condition_variable_any`，用于线程间的同步，允许线程在特定条件成立时才继续执行。
	  
	  3. **原子操作（Atomic Operations）**：
	- `std::atomic` 类模板和相关函数，提供无锁的方式操作共享数据，保证操作的原子性。
	  
	  4. **Futures 和承诺 Promises**：
	- `std::future`、`std::shared_future`、`std::promise`，用于异步编程中管理异步操作的结果，也是一种共享状态的形式。
	  
	  5. **线程安全的队列和容器**：
	- 实现或使用已有的线程安全队列和容器，以安全方式在多线程间传递数据。
- ### 共享状态的同步策略
  
  管理共享状态时，可以采用不同的同步策略：
- **互斥**：使用互斥锁来保护共享状态，防止多线程同时访问。
- **读写锁**：当共享数据的读操作远多于写操作时，使用读写锁（如`std::shared_mutex`）可以提高并发性能。
- **无锁编程**：对于简单的操作，使用原子操作来管理共享状态，避免锁的开销。
- **消息传递**：通过线程间的消息传递而不是共享内存来通信，每个线程处理自己的状态，减少直接共享状态。
- ### 注意事项
- **避免过度同步**：不必要的锁会降低程序的并发性能，尽量减少锁的范围和持有时间。
- **预防死锁**：注意锁的顺序和避免循环等待，使用锁的层次结构或其他策略预防死锁。
- **考虑数据竞争**：确保所有访问共享状态的操作都正确同步，防止数据竞争。
- **设计线程安全的接口**：在设计接口和数据结构时，考虑线程安全，封装共享状态的访问逻辑。