### 在原型设计中使用[[std:memory_order_seq_cst]]次序
logseq.order-list-type:: number
	- 若代码服从 `std: memory_order_seq_cst` 次序，则对其进行分析和推理要比其他内存次序容易得多，因为它令全部操作形成 一个确定的总序列。
	  当基本操作均正常工作后，我们才放宽内存次序约束。在这种意义上，采用其他内存次序其实是一项优化，需要避免过早实施。我们通常只有先完全了解代码全貌，认清哪些代码操作核心数据结构，才可以确定放宽哪些操作的内存次序约束。否则，事情就会很棘手。即便代码在测试过程中正常工作，也无法保证在生产环境下代码依然如此，这令内存次序的放宽调整变得复杂。所以， 仅仅测试代码的运行并不足够，除非我们能够采用测试工具(假如真的存在)，系统化地核查**线程访问内存次序的全部可能的组合**，验证它们是否与指定的内存次序约束保持 一致。
- ### 使用无锁的[[内存回收]]方案
  logseq.order-list-type:: number
	- 无锁代码中的一大难题是内存管理。最基本的要求是，只要目标对象仍然有可能正被其他线程指涉，就不得删除。然而，为了避免过度消耗内存，我们还是想及时删除无用的对象。我们在这一章学习了3 种方法，以确保内存回收满足安全要求：
		- 暂缓全部删除对象的动作，等到没有线程访问数据结构的时候，才删除待销毁的对象；
		  logseq.order-list-type:: number
		- 采用风险指针，以辨识特定对象是否正在被某线程访问；
		  logseq.order-list-type:: number
		- 就对象进行引用计数，只要外部环境仍正在指涉目标对象，它就不会被删除 。
		  logseq.order-list-type:: number
	- 3 种方法的关键思想都是以某种方式掌握正在访问目标对象的线程数目，仪当该对象完全不被指涉的时候，才会被删除。
	- 针对无锁数据结构，还有很多别的方法可以回收内存。譬如，无锁数据是使用[[垃圾回收器]]的理想场景。 若我们得以采用垃圾回收器，即事先晓它具备适时删除无用节点的能力，则算法的实现代码写起来就会轻松 一些。 另一种处理方法是^^重复使用节点^^，等到数据结构销毁时才完全释放它们。由于重用了节点，因此所分配的内存便一直有效，代码从而避开了一些涉及未定义行为的麻烦细节。
	  然而，这种方法有 一个缺点，它导致程序频频出现被称[[ABA问题]]的情形。
- ### 防范[[ABA 问题]]
  logseq.order-list-type:: number
	- 在所有涉及比较-交换的算法中，我们都要注意防范 ABA 问题。该问题产生过程如下。
		- 线程甲 读取**原子变量** x ， 得知其值为 A 。
		  logseq.order-list-type:: number
		- 线程甲根据 A 执行某项操作，比如查找，或如果 x 是指针，则依据它提取出相关值（称为[[ov]]）。
		  logseq.order-list-type:: number
		- 线程甲因操作系统调度而发生阻塞。
		  logseq.order-list-type:: number
		- 另一线程对原子变量 x 执行别的操作，将其值改成 B 。 
		  logseq.order-list-type:: number
		- 又有线程改变了与 A 相关的数据，使得线程甲原本持有的值失效(步骤2 中的 ov ）。这种情形也许是 A 表示某内存地址，而改动操作则是释放指针的目标内存， 或变更目标数据，最后将产生严重后果。
		  logseq.order-list-type:: number
		- 原子变量 x 再次被某线程改动，重新变回 A 。若 x 属于指针型别，其指向目标可能在步骤 5 被改换成一个新对象。
		  logseq.order-list-type:: number
		- 线程甲继续运行，在原子变量 x 上执行**比较-交换操作**，与 A 进行对比。因此比较-交换操作成功执行（因 x 的值依然为 A ），但A的关联数据却不再有效，即原本在步骤2中取得的 ov 已失效，而线程甲却无从分辨，这将破坏数据结构。
		  logseq.order-list-type:: number
		- 如果某数据结构的操作算法涉及空闲内存列表，或者涉及循环使用节点，而不是通过内存分配器回收管理，那么ABA问题就格外常见。
		  logseq.order-list-type:: number
	- 本章内容所涉及的算法均不存在ABA问题，但它很容易由无锁算法的代码引发。
	- 该问题最常见的解决方法之一是，在原子变量 x 中引入一个 ABA 计数器。将变量 x 和 计数器组成单 一结构，作为一个整体执行比较-交换操作。每当它的值被改换，就自增。照此处理，如果别的线程改动了变量 x ，即便其值看起来与最初一样，比较-交换操作仍会失败。
- ### 找出忙等循环，协助其他线程
  logseq.order-list-type:: number
	- 如我们在[无锁队列](((662fab5a-ea4b-4966-8036-b68dbe610254)))中所见，若两个线程同时执行压入操作，其中一个就须等待另一个结束，才可以继续运行。这实质上是一个[[忙等循环]]，如果放任不管，受到阻塞的线程就唯有浪费CPU时间却无计可施。阻塞型操作与使用互斥和锁一样，三者均有可能以忙等循环的方式实现。假设按照调度安排，某线程先开始执行，却因另一线程的操作而暂停等待，那么只要我们修改操作的算法，就能让前者先完成全部步骤，从而避免忙等，操作也不会被阻塞。在无锁队列中，这要求将非原 子变量的数据成员改为原子变量，并采用比较-交换操作设置其值。不过，更复杂的数据结构需要进行更多修改。