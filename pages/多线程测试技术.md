- 需要针对目标函数再现什么工作情景，还为此编写了 一些测试代码来运行目标函数。但我们要怎样才可以确保，线程会按引发错误的调度次 序并发执行，从而复现错误?其实有几种方法可以做到这点，我们从强力测试开始(又名压力测试)。
- ## [[强力测试]]
- 尽管强力测试让我们在一定程度上相信代码正确，但它无法保证找出所有错误。有另外 一种方法，我们称之为[[组合模拟测试]]，只要时间充裕，将其应用到目标代码和受测软件上，就能保证找到错误。
- ## [[组合模拟测试]]
- 现在，我们见到两种测试方法: 一是在普通环境下多次运行测试，但可能错失某些错误；二是在特定的模拟环境中多次运行测试，而这更像是追查已经存在的错误。
  还有其他选择吗？第三种方法是在测试运行的过程中 ，使用专门检测错误的程序库。
- ## 采用特殊的程序库检测错误
	- 这种方法有别于组合模拟测试，不做穷尽排查。我们选取采用特殊实现方式的[[程序库]]，凭借其中的[[同步原语]]（如互斥、锁和条件变量等）检测各种错误。
	  举例说明：这种测试手段通常要求令一份共享数据对应某个特定的互斥，其上的所有访问都必须锁定该互斥。在访问数据的过程中，如果我们可以查验哪些互斥已经锁住，就能进一步核实， 发起访问调用的线程是否对相关互斥正确加锁，若否就报错。 只要通过某种特定方式共享数据，程序库就可以替我们进行检测。
	- 如果某个线程同时持有多个锁，那么程序库的实现还能记录锁操作的序列。若另一个线程以不同的次序锁住同一个互序，即便测试的运行过程并未发生死锁，该操作还是会被记录成潜在的死锁隐患。
	- 我们还能用另一种特殊程序库测试多线程代码，通过其^^多线程原语的实现^^(如互斥和条件变量)，向测试的驱动代码授予超常的控制力度：当多个线程在某互斥或某条件变量上等待时，测试者可以**指定具体哪个线程能获取锁**，或指定 `notify_one()` 调用唤醒具体哪个线程。这使得我们可以还原特定的运行场景，查验代码能否在其中正常工作。
	- [[C++标准库]]的实现将提供上述的一些测试功能，而我们能在标准库的基础上构建其余部分，作为驱动测试的工具。
-