alias:: Banker's Algorithm, 银行家

- 银行家算法（Banker's Algorithm）是一种避免死锁和确保系统资源分配安全的算法，由艾兹格·迪杰斯特拉（Edsger Dijkstra）提出。它主要应用在操作系统的进程调度和资源管理中，用以预防系统进入不安全状态，从而导致死锁。
- ### 算法概述
- 银行家算法模拟了一种银行家在发放贷款时的策略，确保在任何时刻银行（系统）不会因为贷款（分配资源）而无法满足其他客户（进程）的最大可能贷款需求，从而避免银行破产（系统死锁）。
- ### 关键概念
	- **最大需求矩阵（Max）**：每个进程可能请求的最大资源数量。
	  logseq.order-list-type:: number
	- **分配矩阵（Allocation）**：当前每个进程已分配的资源数量。
	  logseq.order-list-type:: number
	- **需求矩阵（Need）**：每个进程尚需的资源数量，计算为 Max - Allocation。
	  logseq.order-list-type:: number
	- **可用资源向量（Available）**：系统当前可用的资源数量。
	  logseq.order-list-type:: number
- ### 安全状态与不安全状态
	- **安全状态**：系统可以按某种顺序（安全序列）分配资源给所有进程，使得每个进程都可以完成运行并释放资源，而不会导致死锁。
	- **不安全状态**：系统不能保证所有进程顺利完成，有可能导致死锁。
- ### 算法步骤
	- **初始化**：输入最大需求矩阵、分配矩阵和可用资源向量。
	  logseq.order-list-type:: number
	- **安全性检查**：
	  logseq.order-list-type:: number
		- 计算需求矩阵和初始可用资源。
		- 尝试找到一个安全序列，使得系统可以按此序列安全地分配资源给进程，直到所有进程都完成。
	- **请求资源**：
	  logseq.order-list-type:: number
		- 当进程请求资源时，系统首先试探性地分配请求的资源。
		- 使用安全性算法检查此次分配后，系统是否还在安全状态。
		- 如果在安全状态，确认分配；如果不在安全状态，拒绝请求以避免死锁。
- ### 示例
- 假设系统有三个进程和三种类型的资源。资源总数和每个进程的最大需求如下所示：
	- 资源总数：A=10, B=5, C=7
	- 最大需求（Max）：
		- P0: A=7, B=5, C=3
		- P1: A=3, B=2, C=2
		- P2: A=9, B=0, C=2
	- 分配（Allocation）：
		- P0: A=0, B=1, C=0
		- P1: A=2, B=0, C=0
		- P2: A=3, B=0, C=2
- 从这些数据出发，我们可以计算需求矩阵和可用资源向量，然后检查系统是否处于安全状态，并对进程请求进行模拟，以确定是否可以安全地分配资源。
- ### 银行家算法的实际应用
- 银行家算法在理论上是一种非常有效的避免死锁的方法，但在实际中，由于需要大量的前期输入和运行时计算，特别是在系统资源和进程数量很大时，实现起来可能较为复杂且耗费资源。因此，在现代操作系统中，它更多地被用于理论教学和设计参考，而实际系统可能采用其他更为简便或高效的策略来管理资源和避免死锁。
  <!--Converted by ToLogseq-->