## 审查代码并定位潜在错误
	- 如果条件允许，自己的代码要让别人审查。因为代码并非由审查者编写，所以他们要 从头思考代码会如何工作，这将有助于他们发现任何可能存在的错误。
	- 如果我们没有同事可以帮忙，就另找 一位朋友，甚至将 代码发布到网络上(在合乎规定的前提下)。若我们真的找不到任何人来审查代码，或 他们看不出任何错误，那也不必忧愁，我们还能采取别的行动。作为多线程编程的新手， **我们大可将代码搁置一段时间**，转而开发应用程序的其他部分，翻阅一下别的书籍，或外出散步。若我们短暂中断，有意识地专注其他事情，我们在潜意识中可能会暗自思考 有关问题。另外，若我们重拾原本搁置的代码，它可能会变得稍微陌生，那样我们就可 能从不同的角度观察它。
	- 除了找别人来审查自己的代码，我们也可以自行审查。其 一种行之有效的方式是， **向别人详细解释代码如何工作**。听取解释的人不必真实存在(许多开发组还专门为此准 备了玩具熊或小黄鸭)。我也亲身实践过，发现编写详细注记有巨大帮助。在解释的过 程中，考察每一行代码，思考它要访问什么数据，会产生什么效果，等等。针对代码自 我发问，给出回答并解释。我认为这种方法具有难以想象的强大作用，通过自问自答， 并仔细考虑代码，潜在的错误常常会“自动现身”。这种问答方式在大多数代码审核中 都会起作用，不局限于自我审查代码。
	- ### 多线程代码审查中需要考虑的问题
		- 让审查者针对代码考虑具体的问题，将有助于发现错误，无 论审查者是代码作着，还是其他人。这些问题可以令审查者集中思绪，专注于代码的相 关细节，从而发现潜藏的错误。
			- 如果要进行并发访问，哪些数据需要保护?
			  logseq.order-list-type:: number
			- 如何确保数据受到保护?
			  logseq.order-list-type:: number
			- 当前线程正在操作受保护的数据，那么其他线程可能同时在执行什么代码?
			  logseq.order-list-type:: number
			- 当前线程持有哪些互斥?
			  logseq.order-list-type:: number
			- 其他线程可能持有哪些互斥?
			  logseq.order-list-type:: number
			- 当前线程和其他线程上的操作需要服从什么次序? 该次序限制如何强制实施?
			  logseq.order-list-type:: number
			- 当前线程所读取的数据是否仍旧合法、有效? 该数据是否有可能已被其他线程改动过?
			  logseq.order-list-type:: number
				- 它表明了一种容易被忽视的错误:若我们释放一个互斥， 再重新获取，就必须假定已经有另一线程改动了共享数据。
			- 如果假定其他线程有可能以并发方式改动数据，那么该改动的发生条件和影响是什么? 我们如何能保证改动不会发生?
			  logseq.order-list-type:: number
				- 如果一份数据具有指针或引用的形式，而它们能被数据作用域之外的代码轻易获得，我们对其的处理就必须格外谨慎，对对象所含的公有数据成员同样如此。
- ## 通过测试定位与并发相关的错误
	- 多线程代码的测试却很困难，因为多线程之间的调度次序不可能精准确定，它们随 着应用软件的多次运行而异。结果，尽管输入的数据相同，但如果代码中潜藏了条件竞争，那么应用软件有时会正确工作，而有时会出错。条件竞争的存在并不会令代码总是 出错，只是间或运行失败。
	- 根据其天然特性，并发相关的错误本来就难以复现。鉴于此，我们必须仔细设计测试方案。按一般经验，如果代码出现问题，我们就设定尽可能小的范围，为之逐一进行 各项测试，只要出错即隔离错误代码。但在并发队列上，更好的测试方式是按并发方式 直接压入和弹出数据，而非分别独立运行相关功能的代码。这种方式需我们在设计代码 时深谋远虑，筹划好随后应该如何测试
	- 另外，我们还要进行不含并发操作的测试，以保证存在的错误与并发相关。如果所 有代码都在单线程上运行，而错误却依旧存在，那就是普通的错误，与并发无关。如果 错误不是由驱动测试的代码检测得出，而是由受测目标范围以外的代码所触发，则这种 非并发测试对追踪错误就特别重要。其原因很简单，即便应用软件中出错的地方恰好涉 及多线程，我们也无法就此断定该错误必然与并发有关。若我们采用线程池模式管理并 发的规模，则工作线程的数目通常由某一配置参数设定。如果线程通过手动管理，为了 进行上述的单线程测试，我们就需修改代码。无论哪种情况，只要将应用软件调整为单 线程模式，而错误依旧，即说明错误成因不是并发功能。举一反 三，若并发应用软件在 多核/ 多处理器系统上有错误，但转到单核系统上(即便它支持多线程运行)错误却无端 消失，那么，我们肯定遇到了条件竞争，并且它很可能与同步操作或内存次序有关。 普通代码的测试主要针对逻辑结构，并发代码则还需另行测试更多项目，并且测试 代码自身的组织结构和测试环境也很重要。如果我们继续思考并发队列，并 之设计测 试代码，就必须考虑到各种各样的场景。
		- 由单一线程调用 `push()` 和 `pop()` ，以保证队列的基本功能运作正常。
		- 在全空的队列上，由一个线程调用 `push()` ，另一个线程同时调用 `pop()`  。
		- 在全空的队列上，由多个线程并发调用 `push()` 。
		- 在全满的队列上，由多个线程并发调用 `push()` 。
		- 在全空的队列上，由多个线程并发调用 `pop()` 。
		- 在全满的队列上，由多个线程并发调用 `pop()` 。
		- 在含有一定数目的元素的半满队列上，由多个线程过量地并发调用 `pop()` ，令弹出操作因元素不足而无法全部成功。
		- 在全空的队列上，由多个线程并发调用 `push()` ，而另一个线程同时并发调用 `pop()` 。 在全满的队列上，由多个线程并发调用 `push()` ，而另一个线程同时并发调用 `pop()` 。
		- 在全空的队列上，多个线程并发调用 `push()` ，同时多个线程并发调用 `pop()` 。
		- 在全满的队列上，多个线程并发调用 `push()` ，同时多个线程并发调用 `pop()`  。
	- 我们先考虑上述全部场景和其他情况，再针对测试环境考虑更多因素。
		- 每项测试中多线程的数目是多少（3、4、1024）？
		- 硬件系统所具有的处理器内核是否足够，能否让每个线程独具一个内核？
		- 应该在哪些处理器架构上运行测试？
		- 我们能否确保系统进行合理调度，使测试中的操作真正实现“同时”和“并发”？
	- 针对各种特定测试场景的细节，我们还需要考虑更多因素。以上 4 个因素都与测试环境有关，其中头、尾两个因素将影响测试代码的组织结构，中间两个因素则与测试所采用的硬件系统有关。
	- 测试所用的线程数目与受测的具体代码有关。
	  我们将介绍几种方法编排测试代码的组织结构，以实现恰当的线程调度。但在此之前，我们先来看看应用软件的代码该如何设计，从而更加便于测试。
- ## 设计可测试的代码
	- 测试多线程代码十分困难，故我们要尽力而为地降低难度。我们力所能及的、最重 要的 一点是设计可测试的代码。^^设计可测试的单线程代码^^中大多数建议至今仍旧适用。通常只要做到以下几点，代码就相对容易测试。
		- 每个函数和类的职责清楚明确。
		  logseq.order-list-type:: number
		- 函数短小精悍，功能切中要害。
		  logseq.order-list-type:: number
		- 接受测试的目标代码处于测试环境中，而实施测试的代码和用例可以**完全掌控该环境**。
		  logseq.order-list-type:: number
		- 执行特定操作的相关代码应该汇聚在一起，以方便测试，不得散布于整个系统中。
		  logseq.order-list-type:: number
		- 着手编写代码前，先想清楚如何对其进行测试。
		  logseq.order-list-type:: number
	- 上述原则对多线程代码同样行之有效。
	- 实际上，相比单线程代码，多线程代码更有必要注重可测试的设计，因为它天生难以测试。最后一项原则非常重要:即便做不到“先编写测试用例，再编写功能代码”，我们至少应该在着手编码前，想清楚该如何测试，如
		- 采用哪些输入、
		- 错误可能在哪些条件下产生、
		- 如何按可能的方式触发代码的错误，等等。
	- 若要设计便于测试的并发代码，其中一种较好的方式就是剔除并发操作。如果我们将代码拆分为几个部分，**一部分专门负责多线程之间的通信，另一部分则在单线程内部操作通信数据，问题即可大大简化**。针对应用程序中的由单线程操作数据的部分，我们使用普通的单线程测试手段即可。并发代码负责处理线程间通信，还要保证**特定数据块每次只由一个线程访问**，以上的拆分处理缩小了它所涉及的范围，使原本难以应对的并发测试变得可追踪错误。
		- 下面举例说明。若我们将应用软件设计成状态机，并由多线程实现，即可将其拆分 成几个部件。只要令每个线程单独处理一个状态的逻辑，分别处理每组可能的输入事件， 保证状态转移和相关操作正确无误，它们就能按单线程方式独立受测试，而其他线程则 作为驱动，提供输入事件作为测试样例。这样，我们就能通过专门设计的简单状态逻辑， 用多线程的并发方式运行状态机，独立测试其核心代码和分发消息的代码，以保证事件 按正确顺序传递给正确的线程。
	- 另一种做法是，将代码划分为^^读取共享数据^^、^^转换数据^^、^^更新共享数据^^ 3 个部分， 由于转换数据的部分都是单线程代码，因此它能以单线程方式测试。多线程的测试原本是个难题，现在就简化成了共享数据的更新和读取。
	- 有 一个细节我们需要特别注意，库函数的调用可能会以内部变量存储状态，如果多 个线程调用同 一组相关的程序库函数，则会在无意中共享该内部变量。然而，这些代码访问共享数据不会导致错误马上出现。我们可以施以恰当的保护和同步措施，或将其替换成其他安全并发的函数， 让多线程通过它们访问数据。
- ## [[多线程测试技术]]
- ## 以特定结构组织多线程的测试代码
	- 我们曾说过，需要找到方法以给出适当的调度次序，令测试中的操作真正实现“同时” 和“并发”。现在是时候了，我们来看看其中关键。 
	  这种测试的根本问题是，**我们需要编排一组线程，为其中每一个线程分别选定目标代码，并令它们同时执行**。在基本情况下，多数测试只考察两个线程，但要增加线程数目并不难。第一步，我们需要区分每项测试所针对的目标代码。
		- 综合配置整体测试环境的代码，必须先于其他任务在最开始运行。
		  logseq.order-list-type:: number
		- 配置线程局部环境的代码与线程自身相关，必须由各线程运行。
		  logseq.order-list-type:: number
		- 我们希望并发运行的代码在每个线程上都要运行。
		  logseq.order-list-type:: number
		- 并发任务完成后才执行的代码，可能也含有针对代码运行结果的断言。 
		  logseq.order-list-type:: number
	- 为了深入解释，我们来考虑一个具体例子：一个线程在空队列上调用 `push()` ，而另一个线程同时调用 `pop()` 。
	- 综合配置的代码很简单：我们必须创建队列。执行 `pop()` 的线程不含与自身相关的局都配置代码。若线程执行 `push()` ，其局部环境则要由与线程相关的代码进行配置，它们与队列的接口函数和存储的对象有关。如果队列存储的对象只能在堆数据段上构建， 或者对象构造的开销大，那么我们在执行 `push()` 的线程上，通过该线程专属的配置代码预设好这些对象，避免构造行为影响测试。但所有情况不可一概而论，若队列用于存储普通的整型值，那么在配置代码中构建`int` 值则毫无意义。受测代码相对简单，一个线程调用一次 `push()` ，另 一个线程调片一次 `pop()` 。但是，线程完结之后的代码该怎么编写?
	- 在本例中，这些代码取决于我们使用的是 `pop()` 的哪个重载。如果 `pop()` 会因队列中 没有数据而阻塞，那么我们显然需要通过后续代码保证， `pop()` 的返回值是先前传入 `push()`  的值。以及队列在  `pop()` 操作之后为空。反之，如果即使队列为空， `pop()` 也不会阻塞，我们则需要查验两种可能结果:
		- 一是 `pop()` 返回之前由 `push()` ()向队列添加数据，且队列为空;
		- 二是 `pop()` 告知调用者无法弹出数据，而队列还含有 一个数据（由 `push()` 后来存入）。
	- 正确的结果只有以上两种，而错误的情况是：
		- `pop()` 告知调用者“没有数据”，队列为空，
		- 或者 `pop()` 返回了数据而队列依然非空。
	- 为了简化测试，假设我们调用了阻塞型的 `pop()` 。 因此，最后部分的代码是通过断言保证的，弹出的值即为添加的值，并且队列为空。
	- 现在，不同部分的代码片段已经明确，我们需要尽力保证它们全都按计划执行。这项测试充分利用了 `std:promise` ，表示各参与要素是否准备妥当，以向前推进。测试首先发起两个执行并发操作的线程，它们分别设立相关的 ``promise`` 表明启动完成；并且，这些线程从 `std:promise` 上分别获取 `std::shared_future` 对象，用以接收“开始”信号。主线程等待并发线程的  `promise`  全部就绪（表明线程成功发起），然后让它们同时开始执行操作。这种模式可以确保每个线程都事先启动完成，针对线程自身提前配置好局部环境，再执行需要并发运行的代码，然后才设立相关的  `promise` 。最后，主线程等待并发操作的线程结束，并查验数据和容器的最终状态。
	- 如果有异常抛出，就令 `go` 实例跳过就绪信号，进而使线程在 `go` 上空等，因此，我们还需处理异常以保证不会发生这种情形。
	- 代码清单 1 展了测试代码的一种组织结构。
	  ```cpp
	  void test_concurrent_push_and_pop_on_empty_queue()
	  {
	      threadsafe_queue<int> q; //1
	  
	      std::promise<void> go,push_ready,pop_ready; //2
	      std::shared_future<void> ready(go.get_future()); //3
	  
	      std::future<void> push_done; //4
	      std::future<int> pop_done;
	  
	      try
	      {
	          push_done=std::async(std::launch::async, //5 强制在不同的线程上执行
	                               [&q,ready,&push_ready]()
	                               {
	                                   push_ready.set_value();
	                                   ready.wait(); //等待 go.set_value()
	                                   q.push(42);
	                               } // lambda 表达式
	              );
	          pop_done=std::async(std::launch::async, //6
	                              [&q,ready,&pop_ready]()
	                              {
	                                  pop_ready.set_value();
	                                  ready.wait();
	                                  return q.pop(); //7
	                              }
	              );
	          push_ready.get_future().wait(); //8 等待 push_ready.set_value();
	          pop_ready.get_future().wait();
	          go.set_value(); //9
	  
	          push_done.get(); //10
	          assert(pop_done.get()==42); //11
	          assert(q.empty());
	      }
	      catch(...)
	      {
	          go.set_value(); //12
	          throw;
	      }
	  }
	  
	  ```
	- 代码清单 1 的结构非常符合前文的描述。一开始，我们进行综合配置，首先创建一个空队列①，接着为各步骤创建 `promise`，它们的用途是产生^^就绪信号^^ ②，并从 `go` 实例获取相应的 `std:share_future` 对象③。然后，我们创建两个 `future` ，用于表明并发运行的线程是否结束④。
	  综合配置必须处于 `try` 块之外，这样即使发生了异常，我们也依然可以设置 `go` 成立以触发信号'，而无须等待执行并发操作的测试线程运行结束。尽管我们并不希望死锁在测试代码中出现，但以上做法有可能导致死锁。
	- 我们在 `try` 块中以[[std:launch:async]]方式启动线程⑤⑥，从而保证每个任务都在自已的线程上执行。请注意，本例中我们运行异常安全的任务，通过 `std:async` 发起线程，而非通过构建普通的 `std:thread` 对象，这样会稍微简化代码，因为 [[future]] 的析构函数会**自动汇合线程**。各任务的细节通过 lambda 函数的捕获列表设定：它们都按引用方式访问队列 `q` ；还按引用方式分别获得一个 `promise` 对象，通过它向外发送就绪信号表示^^启动完成^^；另外接收 `ready` 的副本（`ready` 从 `go` 实例中取得，用于接收主线程发出的“开始执行”信号）。
	- 前文曾解释过，每个任务都设立与自身相关的就绪信号（表示“启动完成”），然后等到主线程发出“开始执行”信号，才开始运行受测代码。但主线程的行为恰好相反，它先等着接收两个并发线程的就绪信号⑧，之后再通知它们开始运行真正的测试代码⑨。
	- 最后，主线程在异步任务返回的 `future` 上调用 `get()`，等任务完成以后查验结果⑩⑪。
	  请注意 `pop()`  任务所获取的值通过 `future` 返回⑦，故我们可以在断言中直接使用该结果①。
	- 若有异常抛出，我们则创建 `go` 实例，避免线程空等，也防止重新抛出异常⑫。与并发任务对应的 `future` 对象留待最后声明④，这样它们就会最早销毁。如果任务尚未完成，其析构函数会等到它们完成。
	- 虽然上例只测试了两个简单的调用，但涉及的公式化代码都相当多，而为了让测试能尽可能多地排查出错误，我们很有必要使用类似的代码。
	  例如在测试代码中，我们咩有直接创建新线程（而非先发起两个执行并发操作的线程，再使之等待 `go` 实例发出信号），**因为启动线程的过程十分耗时，通过这种利用 `future` 的方式，可以确保两个线程都先运行起来，再在相同的 `future` 上阻塞**。随后解除 `future` 的阻塞，即令两个线程同时执行并发操作。一旦读者熟悉本例的代码结构，就能简单地依照相同模式创建新的测试代码。有些测试需动用的线程超过两个，该模式可以方便地扩展，加入更多线程。
	- 至此，我们学习了如何测试多线程代码的正确性。
- ## 测试多线程代码的性能
	- 我们在应用中采用并发功能的主要原因之一是，借助多核处理器来提升性能。所以，代码测试是一种重要手段，可以保障程序性能确实有所改进，这跟我们所尝试的其他优化手段类似。
	- 利用并发提升性能的具体问题在于[[可伸缩性]]。如果其他条件相同，那么与单核机器相比，我们希望在 24 核的机器上运行代码的效果是速度大致提升到原来的 24 倍，或处理 24 倍的数据量。我们不想出现以下情形：代码在双核机器上以双倍速运行，但在24核机器上运行速度却较慢。
	  若代码中的某关键部分只能在一个线程上运行，则会限制潜在的性能增益。所以，我们在开始测试性能之前，应该审视代码的整体设计，以便清醒认识是否确有希望将速度提升 24 倍，亦或存在串行代码，限制了性能改进的程度，最多仅能提速 3 倍。
	- 我们在前文已经见到，若多个处理器为访问同一个数据结构而争夺资源，则会导致严重的性能问题。如果处理器数目较少，某些程序的性能可能还不错，然而一旦处理器数目大幅度增加，争夺资源的行为也随之加剧，而那些程序没有做好可伸缩性处理，性能表现反而较差。
	- 因此，若要测试多线程代码性能，最好**在尽量多的、不同硬件配置的系统上进行**，这样我们才能清楚分析软件的可伸缩性。至少，我们应该既在单处理器系统上测试，又在手头可用的多处理器系统上测试（处理器核心数目越多越好）。
-
-