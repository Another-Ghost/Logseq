alias:: 单例模式

- 单例模式（Singleton Pattern）是一种常用的设计模式，用于限制一个类只能有一个实例，并提供一个全局访问点来获取这个实例。这种模式确保在整个应用程序中，一个类只有一个实例存在，同时提供一个易于访问的全局节点。
- ### 单例模式的组成：
	- **私有构造函数**：确保不能从类外部使用 `new` 关键字直接实例化。
	  logseq.order-list-type:: number
	- **私有静态实例**：类的唯一实例，私有静态成员。
	  logseq.order-list-type:: number
	- **公有静态方法**：全局访问点，用于获取单例对象，通常命名为 `getInstance()`。
	  logseq.order-list-type:: number
- ### 单例模式的关键特点：
	- **控制资源的访问**：例如，控制对[[配置文件]]、[[线程池]]或[[数据库]]的访问。
	- **节约资源**：通过确保实例只被创建一次，节省系统资源。
	- **全局访问点**：提供了一个全局访问点以访问实例，从而避免了将对象传递到需要它的每一个对象。
- ### 示例代码：
  以下是使用 C++ 实现的线程安全的单例模式示例：
  ```cpp
  #include <iostream>
  #include <mutex>
  
  class Singleton {
  private:
    static Singleton* instance;
    static std::mutex mutex;
  
  protected:
    // 私有构造函数确保不能外部实例化
    Singleton() {}
  
  public:
    // 禁止拷贝构造函数和赋值操作
    Singleton(const Singleton&) = delete;
    Singleton& operator=(const Singleton&) = delete;
  
    // 全局访问点
    static Singleton* getInstance() {
        if (instance == nullptr) {
            std::lock_guard<std::mutex> lock(mutex);
            if (instance == nullptr) {
                instance = new Singleton();
            }
        }
        return instance;
    }
  };
  
  // 初始化静态成员
  Singleton* Singleton::instance = nullptr;
  std::mutex Singleton::mutex;
  
  int main() {
    // 获取单例对象
    Singleton* singleton = Singleton::getInstance();
    std::cout << "Singleton instance address: " << singleton << std::endl;
    return 0;
  }
  ```
- ### 使用场景：
	- 当你想确保全局只有一个实例，如配置管理器或数据库连接池时。
	- 当需要严格控制外部对某个对象的访问时。
- ### 注意事项：
- 在使用单例模式时，虽然它为设计提供了严格的资源控制和易于访问的全局访问点，但也存在一些潜在的问题和注意事项。下面详细解释上文中提到的几个重要方面：
	- ### 高耦合性 
	  logseq.order-list-type:: number
	  单例模式提供了一个全局可访问的实例，这使得很多组件可能依赖于这个单一的实例来进行操作。这种高度的中心化可以导致代码之间的耦合度过高，使得各部分组件难以独立于该单例实例存在。例如，如果许多不同的类都使用单例类提供的数据或服务，那么这些类与单例类之间形成了紧密的耦合关系，修改单例类可能需要同时修改依赖于它的多个类，这违背了软件设计中推崇的低耦合原则。
	- ### 多线程同步问题 
	  logseq.order-list-type:: number
	  在多线程应用中实现单例模式时，确保线程安全是非常重要的。如果多个线程尝试同时创建单例的实例，可能会导致多个实例被创建，从而违反了单例模式的原则。解决这个问题通常需要使用锁（如互斥锁）或其他同步机制来确保在任何时候只有一个实例被创建。这可能会引入额外的性能开销，尤其是在高并发的环境下。
	- ### 滥用单例模式 
	  logseq.order-list-type:: number
		- **难以追踪的依赖关系**：
		  logseq.order-list-type:: number
		  单例作为一个全局可访问的实体，可以在应用程序的任何地方被访问和修改。这种广泛的访问性导致难以跟踪哪些部分的代码依赖于单例提供的数据或服务。这种隐式的依赖关系使得代码的理解和维护变得更加困难。
		- **全局状态管理问题**：
		  logseq.order-list-type:: number
		  当单例用于存储全局状态时，**任何对单例状态的修改都会影响到依赖于该状态的所有功能**。这种全局影响使得状态管理变得复杂，特别是在多线程环境中，不同的线程可能会并发读写单例的状态，从而引入[[竞态条件]]和同步问题。
		- **单元测试难度增加**：
		  logseq.order-list-type:: number
		  使用单例存储全局状态会使单元测试变得更加困难。[[单元测试]]通常需要在一个可预测和隔离的环境中测试代码，但如果测试的组件依赖于全局可变的单例，就需要**在每个测试之前重置单例的状态**。这不仅增加了测试的复杂性，还可能导致测试结果的不稳定。
		- **代码扩展和修改的困难**：
		  logseq.order-list-type:: number
		  如果单例被广泛用作全局状态的存储，任何需要扩展或修改单例功能的行为都可能影响到依赖于此单例的所有功能。这种高[[耦合]]性导致即使是小的改动也需要广泛的代码审查和可能的重构。
	- ### 对象生命周期管理困难 
	  logseq.order-list-type:: number
	  单例模式控制了实例的创建和生命周期，这使得控制单例的销毁时间和方式变得复杂。在某些编程环境中，如C++，管理单例的生命周期尤其棘手。如果单例持有资源，如文件句柄或网络连接，不恰当的管理可能会导致资源泄漏。此外，单例的析构时间也可能影响到它所依赖的其他资源的状态。
- ### 建议的使用准则：
	- **限制使用范围**：
	  logseq.order-list-type:: number
	  只在真正需要全局唯一访问点的场景下使用单例模式，例如日志记录器、配置管理器或硬件接口管理。
	- **[[依赖注入]]**：
	  logseq.order-list-type:: number
	  使用依赖注入（DI）技术来减少代码对单例的直接依赖。通过DI容器提供所需的依赖，可以更容易地控制依赖关系，同时提高代码的可测试性和可维护性。
	- **使用更局部的状态管理**：
	  logseq.order-list-type:: number
	  考虑使用更加局部的状态管理策略，比如传递对象到需要它们的函数和类，而不是依赖全局的单例实例。
	- **设计清晰的接口**：
	  logseq.order-list-type:: number
	  单例应该有一个清晰定义的职责和提供的服务，避免将单例变成一个“上帝对象”，承担过多的职责和状态管理。
	- **线程安全**：确保单例的实现是线程安全的，特别是在多线程环境中。
	  logseq.order-list-type:: number
- 单例模式是一种强大但需谨慎使用的模式，它提供了一种严格控制资源访问和管理的方法，但同时也需要注意避免滥用这一模式，造成代码不必要的复杂性和问题。
-