alias:: 垃圾收集器

- [[垃圾收集器]]是一种[[动态内存分配器]]，它自动释放程序不再需要的[[已分配块]]。这些块被称为[[垃圾]] 。
- ## 垃圾收集器的基本知识
	- 垃圾收集器将内存视为一张 *有向[[可达图]]* , 其形式如图所示。该图的 *节点* 被分成一组[[根节点]] 和一组[[堆节点]]。
		- ![image.png](../assets/image_1702477592208_0.png){:height 256, :width 634}
		- 每个[[堆节点]]对应于[[堆]]中的一个[[已分配块]]。
		- [[有向边]] $p\to q$ 意味着块 $p$ 中的某个位置指向块 $q$ 中的某个位置。
		- *根节点* 对应于这样一种不在 堆 中的位置，它们中包含指向堆中的 *指针* 。这些位置可以是 *寄存器* 、*栈里的变量* ，或者是 *虚拟内存中读写数据区域内的全局变量* 。
		- 当存在一条从任意 *根节点* 出发并到达 $p$ 的[[有向路径]]时，我们说节点 $p$ 是[[可达的]]。在任何时刻，*不可达节点* 对应于[[垃圾]]，是不能被应用再次使用的。
		- 垃圾收集器维护 *可达图* 的某种表示，并通过[[释放]] *不可达节点* 且将它们返回给[[空闲链表]]，来定期地 *回收* 它们。
	- 像 ML 和 Java 这样的语言的垃圾收集器，对应用如何创建和使用指针有很严格的控制，能够维护可达图的一种精确的表示，因此也就能够回收所有垃圾。
	- 然而，诸如 C 和 C++ 这样的语言的收集器通常不能维持可达图的精确表示。这样的收集器也叫做[[保守的垃圾收集器]]。 
	  从某种意义上来说它们是保守的，即每个可达块都被正确地标记为可达了，而一些 *不可达节点* 却可能被错误地标记为可达。
	  收集器可以按需提供它们的服务，或者它们可以作为一个和应用并行的独立[[线程]]，不断地更新 *可达图* 和 *回收垃圾* 。
		-