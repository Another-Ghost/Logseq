alias:: 并发, 并发性

- {{renderer :tocgen2}}
- # 定义
	- *计算机* 的[[并发]]，指在单个系统里**同时**执行多个独立的任务。
	- ## [[任务切换]]
	- ## [[硬件并发]]
- # 并发的方式
	- ## [[多进程并发]]
	- ## [[多线程并发]]
	- 多个 单线程/进程间的通信 ，要比单一进程中 多线程通信 的开销大，若不考虑共享内存可能带来的问题，多线程将会成为主流语言更青睐的并发方式。
	  此外，[[C++]]标准并未对[[进程通信]]提供原生支持，所以实现会依赖于平台相关的API。
	  #+BEGIN_CAUTION
	  因此，之后的内容只关注多线程的并发，之后所提到“并发”，均指[[多线程并发]]。
	  #+END_CAUTION
- # 并发与并行
	- 对多线程来说，这两个概念大部分是重叠的，用来描述**硬件同时执行多个任务**的方式。
	- 这两个术语存在的目的，就是为了区别多线程中不同的关注点。
		- [[并行]]更加注重**性能**。使用硬件提高数据处理速度时，会讨论程序的并行性。
		- 当关注重点在于[[任务分离]]或[[任务响应]]时，会讨论程序的[[并发性]]。
- # 为什么使用并发
  有两个原因：
	- ## 分离关注点
		- [[分离关注点]]方法通过将相关的代码与无关的代码分离，可以使程序更容易理解和测试，从而减少出错的可能。
		  即使一些操作需要同时进行，依旧可以使用[[并发]]来分离不同的功能区域。
		  若不显式地使用并发，就得编写一个任务切换机制，或者在操作中主动地调用一段不相关的代码。
		  #+BEGIN_Pinned
		  假设有一个用户界面的处理密集型应用——DVD播放程序。这样的应用程序，应具备这两种功能：一，要从光盘中读出数据，对图像和声音进行解码，之后把解码出的信号输出至视频和音频硬件中进行处理，从而实现DVD的播放；二，接收来自用户的输入，当用户单击“暂停”、“返回菜单”或“退出”按键的时候执行对应的操作。当应用是单个线程时，应用需要在回放期间定期检查用户的输入，这就需要把“DVD播放”代码和“用户界面”代码放在一起。如果使用多线程方式来分离这些关注点，“用户界面”代码和“播放DVD”代码不需要放在一起：一个线程可以处理“用户界面”，另一个进行“播放DVD”。它们之间会有交互(用户点击“暂停”)，不过任务需要人为的进行关联。
		  #+END_Pinned
		- 这种情况下，对线程的划分是基于概念上的设计，所以**线程数 不再依赖 CPU[[核心]]数**。
	- ## 性能
		- [[多处理器系统]]已经存在了几十年，直至现今，它们也只在超级计算机、大型机和大型服务器系统中才能看到。
		  然而，芯片制造商越来越倾向于芯片的多核设计，即在单芯片上集成2、4、16或更多的处理器，从而获取更好的性能。
		- 有两种利用并发来提高性能的方式：
			- 将单个任务分成几部分并行运行，从而降低总运行时间，这就是[[任务并行]]。
			  logseq.order-list-type:: number
			  这是一个相当复杂的过程，因为各个部分之间可能存在着 依赖。
			  区别可能是在过程方面：
				- 一个线程执行算法的一部分，而另一个线程执行算法的另一个部分，或是在处理数据。
				  logseq.order-list-type:: number
				- 每个线程在不同的数据块上执行相同的操作(第二种方式)。这种方法被称为[[数据并行]]。
				  logseq.order-list-type:: number
				- 那些容易并行化的算法通常被称为[[embarrassingly parallel]]。尽管这个说法似乎暗示了你可能会因为代码如此容易并行化而感到尴尬，但实际上这是一件好事。
				  Embarrassingly parallel算法具有良好的可扩展性属性——随着可用[[硬件线程]]数量的增加，算法中的并行性可以相应**增加**。
				- 对于那些不是那么容易并行化的算法部分，您可能能够将算法分为固定（因此不可扩展）数量的并行任务。
			- 利用并行来解决更大的问题：每次处理尽可能多的文件（同时执行相同的操作）。
			  logseq.order-list-type:: number
			  虽然，这是[[数据并行]]的一种应用，但着重点不同。处理等量数据仍然需要同样的时间，但现在在相同的时间内处理了更多的数据。
			  这种方法也有限制，并非所有情况下都是有效的。不过，这种方法所带来的[[吞吐量]]提升，可以让某些功能成为可能。
			  #+BEGIN_Pinned
			  如果可以并行处理图像的不同区域，程序就可以处理更高分辨率的视频。
			  #+END_Pinned
- # 什么时候不使用并发
  不使用并发的唯一原因就是**收益比不上成本**。
	- 使用并发的代码在很多情况下难以理解，因此编写和维护多线程代码会产生脑力成本，而增加的**复杂性**也可能会引起更多的错误。
	  除非潜在的性能增益足够大或关注点分离地足够清晰，能抵消为确保正确开发所需的额外时间，以及维护代码的额外成本；否则，勿用并发。
	  <绝大多数情况下，用过高的复杂性和过大的出错率，来交换小幅度的性能收益是不划算的。即便是瓶颈出现在C++标准库的工具中，也可能由低劣的程序设计造成。例如，如果过多的线程竞争一个互斥单元，将会很明显的影响性能。与其在互斥操作上耗费时间，不如重新设计，减少互斥单元上的竞争。
	- 同样地，性能增益可能会小于预期。启动 线程 时存在**固有开销**，因为[[操作系统]]需要分配[[内核资源]]和[[堆栈空间]]，才能把新线程加入[[调度器]]中。如果在线程上的任务完成得很快，那么 实际执行任务的时间 要比 启动线程的时间 **小很多**，这会导致应用的整体性能不如直接使用单线程。
	- 此外，线程的**资源有限**。
	  如果太多的线程同时运行，则会消耗很多操作系统资源，从而使得操作系统整体上运行得更加缓慢。
	  不仅如此，因为每个线程都需要一个**独立的堆栈**，所以运行太多的线程也会耗尽进程的 *可用内存空间* 。
	  #+BEGIN_Pinned
	  假设有一个用户界面的处对于一个可用地址空间为4GB(32bit)的架构来说，这的确是个问题：如果每个线程都有一个1MB的堆栈(很多系统都会这样分配)，那么4096个线程将会用尽所有地址空间(不会给代码、静态数据或者堆数据留有任何空间)。
	  即便是64位(或者更大)的系统，不存在这种地址空间限制，但其他资源也是有限的：如果你运行了太多的线程，也会出问题。尽管[[线程池]]可以用来限制线程的数量，但也并不是什么灵丹妙药。
	  #+End_Pinned
	- 最后，运行越多的线程，操作系统就需要越多的[[上下文切换]]，每一次切换都需要耗费时间。所以在某些时候，增加线程实际上会降低应用的**整体性能**。如果试图得到系统的最佳性能，可以考虑使用[[硬件并发]](或不用)，并调整运行线程的数量。
	- 因此，应用中**只有性能关键部分**，才值得并发化。
	  当然，如果性能收益仅次于设计清晰或[[分离关注点]]，也可以使用多线程。
	-