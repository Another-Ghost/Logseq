- 设计并发数据结构的基本意义在于允许多个线程能够同时访问数据结构，执行相同或不同的操作，同时每个线程都能看到数据结构的**一致视图**。这样可以确保不会丢失或损坏数据，所有[[不变性]]（invariants）得以维护，且不会出现问题性的[[竞态条件]]（race conditions）。这种数据结构被称为^^线程安全^^（thread-safe）。
- 通常，数据结构只对特定类型的并发访问是安全的。可能允许多个线程同时执行一种操作，而另一种操作则需要单个线程独占访问。或者，在多个线程执行不同动作时，可以安全地并发访问数据结构，而多个线程执行相同动作可能会引起问题。
- 然而，真正的并发设计意味着不仅仅是这些：它还意味着为访问数据结构的线程提供并发的机会。[[互斥锁]]（mutex）的本质是提供互斥性：任何时候只有一个线程可以获取互斥锁。互斥锁通过明确阻止真正的并发访问来保护数据结构。这被称为[[串行化]]（ serialization）：线程轮流访问由互斥锁保护的数据；它们必须串行而非并行地访问数据。
- 一些数据结构比其他的更适合真正的并发，但在所有情况下，理念都是相同的：**受保护区域越小，串行化的操作就越少**，并发的潜力就越大。
- ## 设计并发数据结构的指导原则
- 当为并发访问设计数据结构时，你需要考虑两个方面：
	- 确保访问是安全的, 
	  logseq.order-list-type:: number
	- 并且能够实现真正的并发访问。
	  logseq.order-list-type:: number
- ### 如何使数据结构线程安全
  logseq.order-list-type:: number
	- 主要分为以为几点
		- 确保没有任何线程能看到由于其他线程的操作而打破了数据结构的[[不变性]]的状态。
		  logseq.order-list-type:: number
		- 注意避免数据结构接口中固有的[[竞态条件]]，通过提供完成整个操作的函数而不是单个操作步骤的函数。
		  logseq.order-list-type:: number
		- 注意数据结构在[[异常]]存在时的行为，以确保不破坏不变性。
		  logseq.order-list-type:: number
		- 通过限制锁的范围并尽可能避免^^嵌套锁^^，最小化使用数据结构时发生[[死锁]]的机会。
		  logseq.order-list-type:: number
	- 在你考虑这些细节之前，思考你想对数据结构的用户施加什么限制也很重要；如果一个线程通过特定函数访问数据结构，哪些函数是安全的可以由其他线程调用？这是一个关键的问题。
	- 通常，构造函数和析构函数需要对数据结构的独占访问，但这取决于用户确保在构造完成之前或析构开始后不去访问它们。
	  如果数据结构支持赋值、交换（`swap()`）或复制构造，则作为数据结构的设计者，你需要决定这些操作是否可以与其他操作同时并发调用，或者它们是否要求用户即使大多数操作可以在没有任何问题的情况下由多个线程同时调用，也需要确保独占访问。
- ### 如何实现真正的并发访问
  logseq.order-list-type:: number
	- 作为数据结构设计者你需要自问的问题列表：
		- **锁的范围**能否被限制，以允许某些操作部分在锁外执行？
		  logseq.order-list-type:: number
		- 数据结构的**不同部分**能否用不同的互斥锁保护？
		  logseq.order-list-type:: number
		- 所有操作都需要相同**级别**的保护吗？
		  logseq.order-list-type:: number
		- 对数据结构进行**简单的更改**能否在不影响操作语义的情况下提高并发的机会？
		  logseq.order-list-type:: number
	- 所有这些问题都由一个单一的理念指导：如何最小化必须发生的[[串行化]]，并实现最大程度的真正并发？
	-