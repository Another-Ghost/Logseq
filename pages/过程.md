alias:: procedure, procedures

- [[过程]]是软件中一种很重要的抽象。它提供了一种封装代码的方式，用一组指定的[[参数]]和一个可选的[[返回值]]实现了某种功能。然后，可以在程序中不同的地方调用这个 过程 。
- 过程的形式多样：函数（[[function]]）、方法（[[method]]）、子例程([[subroutine]])、 处理函（[[handler]]）等等，但是它们有一些共有的特性：
  要提供对[[过程]]的 *机器级* 支持，必须要处理许多不同的属性。为了讨论方便，假设过程 P 调用过程 Q ， 执行后返回到 P 这些动作包括下面一个或多个机制 ：
	- [[转移控制]]。在进入过程 Q 的时候，[[程序计数器]]必须被设置为 Q 的代码的[[起始地址]]，然后在返回时，要把 程序计数器 设置为 P 中调用 Q **后面**那条指令的地址。
	  logseq.order-list-type:: number
	- [[传递数据]]。P 必须能够向 Q 提供一个或多个[[参数]]，Q 必须能够向 P 返回一个[[返回值]]。
	  logseq.order-list-type:: number
	- *分配和释放内存* 。在开始时，Q 可能需要为[[局部变量]] *分配* 空间，而在返回前，又必须 *释放* 这些存储空间。
	  logseq.order-list-type:: number
- # x86-64 的过程实现
	- ## [[运行时栈]]
	- ## 栈上的局部数据存储
		- 有些时候，[[局部数据]]必须存放在[[内存]]中，常见的情况包括：
		  • [[寄存器]]不足够存放所有的[[局部数据]]。
		  • 对一个[[局部变量]]使用[[取地址运算符]]`＆`，因此**必须能够为它产生一个[[地址]]** 。
		  • 某些[[局部变量]]是[[数组]]或[[结构体]]，因此必须能够通过数组或结构体[[引用]]被访问到 。
		- 一般来说，过程 通过减小[[栈指针]]在栈上分配空间 。分配的结果作为栈帧的一部分，[图](((65572e30-eb7f-45cd-b346-42285071d651)))中标号为[[局部变量]]。
	- ## [[寄存器]]中的局部存储空间
		- 寄存器组是**唯一**被**所有**[[过程]]**共享**的资源。
		  虽然在给定时刻只有一个过程是活动的，我们仍然必须确保当一个过程（[[调用者]]）调用另一个过程（[[被调用者]]）时，被调用者不会覆盖调用者稍后会使用的寄存器值。为此，x86-64 采用了一组统一的寄存器使用惯例，所有的过程（包括程序库）都必须遵循。
		- 根据惯例，寄存器 %rbx 、 %rbp 和 %r12~%r15 被划分为[[被调用者保存寄存器]]。当 过程P 调用 过程Q 时，Q 必须保存[[被调用者保存寄存器]]的值，保证它们的值在 Q 返回到 P 时与 Q 被调用时是一样的。
		  过程 Q 保存一个寄存器的值不变，
			- 要么就是根本不去改变它，
			- 要么就是把原始值压入[[栈]]中，改变寄存器的值，然后在返回前从栈中弹出旧值。压入寄存器的值会在栈帧中创建[图](((65572e30-eb7f-45cd-b346-42285071d651)))中标号为“保存的寄存器”的一部分。
		- 所有其他的寄存器，除了[[栈指针]] %rsp, 都分类为[[调用者保存寄存器]]。这就意味着任何函数都能修改它们。
		  可以这样来理解“调用者保存”这个名字：
		  过程P 在某个此类寄存器中有局部数据，然后调用 过程Q 。因为 Q 可以随意修改这个寄存器，所以在调用之前首先保存好这个数据是 P( 调用者）的责任。
	- ## [[变长栈帧]]