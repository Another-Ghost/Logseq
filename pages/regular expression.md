alias:: 正则表达式, regex

- 正则表达式（Regular Expression，简称Regex）是一种强大的文本处理工具，用于字符串的搜索、替换、检索和验证。它通过定义一个搜索模式来匹配字符串中的字符组合。正则表达式在很多编程语言和工具中都有支持，包括JavaScript、Python、Java、PHP、Perl等。
- ### 基本组成
	- **字面量字符**：直接匹配字符本身，例如，`a`匹配字符"a"。
	- **元字符**：具有特殊含义的字符，例如：
		- `.`：匹配除换行符之外的任意单个字符。
		- `\d`：匹配任意数字，等价于`[0-9]`。
		- `\w`：匹配任意字母数字字符，等价于`[a-zA-Z0-9_]`。
		- `\s`：匹配任意空白字符（包括空格、制表符、换行符等）。
- ### 使用量词
  量词用于指定一个元素必须出现的次数：
	- `*`：匹配前面的元素零次或多次。
	- `+`：匹配前面的元素一次或多次。
	- `?`：匹配前面的元素零次或一次。
	- `{n}`：匹配前面的元素恰好n次。
	- `{n,}`：匹配前面的元素至少n次。
	- `{n,m}`：匹配前面的元素至少n次，但不超过m次。
- ### 使用分组和引用
	- **分组**：通过括号`()`将字符组合在一起，可以作为一个单独的单元进行操作。例如，`(abc)+`匹配一个或多个连续的"abc"。
	- **引用**：可以在同一个正则表达式内部引用之前的分组。例如，`(abc)\1`匹配"abcabc"。
- ### 使用边界匹配符
	- `^`：匹配 被匹配字符串 的开始。
	- `$`：匹配 被匹配字符串 的结束。
	- `\b`：匹配一个单词边界，即字与空格间的位置。
- ### 使用[[字符集]]
	- `[abc]`：匹配任何一个列在方括号中的字符。
	- `[^abc]`：匹配任何不在方括号中的字符。
	  collapsed:: true
		- `[!-~]`是一个字符类范围，用于匹配ASCII表中的可打印字符。这个范围包括了从`!`字符（ASCII码33）到`~`字符（ASCII码126）的所有字符。这个范围涵盖了大多数标点符号、数字、大写字母、小写字母和一些特殊符号。
- ### [[正则表达式修饰符]]（Flags）
  修饰符改变正则表达式的搜索行为。常见的修饰符包括：
	- `g`：全局搜索，匹配字符串中的所有实例。
	- `i`：不区分大小写。
	- `m`：[[多行模式]]，影响`^`和`$`的行为。
	- `s`：使 `.` 匹配包括换行符在内的所有字符
	- `u`：Unicode 模式，正确处理大于 `\uFFFF` 的Unicode字符
-
- ## 高级特性
- ### [[后瞻断言]]（Lookbehind Assertions）
  后瞻断言允许在匹配时考虑到位于当前匹配点之前的字符序列。它分为肯定后瞻断言和负向后瞻断言。
	- **肯定后瞻断言** (`(?<=...)`): 确保某个模式存在于当前匹配位置的前面。
	- **负向后瞻断言** (`(?<!...)`): 确保某个模式不存在于当前匹配位置的前面。
- ### [[零宽断言]]（Lookahead Assertions）
  零宽断言是在当前匹配位置之后进行查找，但不消耗字符（即不前进匹配指针）。
	- **肯定零宽先行断言** (`(?=...)`): 确保后面的字符满足特定的模式。
	- **负向零宽先行断言** (`(?!...)`): 确保后面的字符不满足特定的模式。
- ### [[非捕获组]]（Non-Capturing Groups）
  非捕获组 (`(?:...)`) 允许对一部分正则表达式进行分组，但不保存该分组用于后续的引用。这对于优化性能很有帮助。
- ### 命名捕获组（Named Capturing Groups）
  命名捕获组 (`(?<name>...)`) 允许为正则表达式的一部分命名，使得可以通过名称而不是数字索引来引用匹配的子字符串。
- ### 前瞻和后顾引用（Backreferences）
  前瞻引用允许在正则表达式后面部分引用前面匹配的组。后顾引用（如 `\1`, `\2` 等）允许匹配与之前捕获的组相同的文本。
- ### [[条件表达式]]（Conditional Expressions）
  条件表达式允许正则表达式根据前面的某个部分是否匹配来改变行为。
- ### Unicode 属性转义（Unicode Property Escapes）
  Unicode 属性转义 (`\p{...}` 和 `\P{...}`) 允许根据字符的Unicode属性来匹配字符，是处理[[Unicode]]文本的强大工具。
- ### 模式修饰符（Pattern Modifiers）
  一些正则表达式引擎支持在表达式内部使用模式修饰符来动态改变处理模式。
- ### 正则表达式的注释
  某些正则表达式引擎允许在表达式中加入注释，以提高可读性。
- ## [[JavaScript/regular expression]]
- ## [[正则表达式的原理]]
- ## 正则表达式的性能优化
- 优化正则表达式的性能可以避免不必要的计算开销和潜在的性能瓶颈。这里是一些提高正则表达式性能的通用建议：
- ### 1. **避免[[贪婪量词]]**
  ^^贪婪量词^^（如 `.*` 和 `.+`）会尽可能多地匹配字符，这可能导致大量的[[回溯]]，尤其是在匹配失败时。使用[[非贪婪量词]]（如 `.*?` 和 `.+?`）可以减少回溯的次数。
- ### 2. **使用具体字符类**
  尽可能使用具体的字符类。例如，如果你知道一个字符串只包含数字，使用 `\d` 比使用 `.` 更高效。字符类如 `\w`、`\d`、`\s` 等比使用 `.` 或者自定义的字符集（如 `[a-zA-Z0-9]`）更优。
- ### 3. **[[锚点]]的使用**
  使用^^锚点^^（如 `^` 和 `$`）可以限定匹配必须发生在字符串的开始或结束，这样可以减少正则表达式引擎尝试匹配的位置数量。
- ### 4. **避免[[回溯]]**
  尽量减少需要大量回溯的正则表达式。复杂的正则表达式（尤其是包含嵌套量词和多个选择分支的正则表达式）可能导致指数级的回溯，严重影响性能。
- ### 5. **预编译正则表达式**
  如果你在代码中多次使用同一个正则表达式，考虑预编译这个正则表达式，避免每次使用时都重新编译。
- ### 6. **避免不必要的[[捕获组]]**
  如果你不需要捕获组中的数据，使用非捕获组（如 `(?:...)`）可以减少正则表达式引擎需要保存的信息，从而提高性能。
- ### 7. **使用特定方法**
  如果你只需要检查字符串是否匹配正则表达式（不需要提取数据），使用 `test` 方法比 `match` 或 `exec` 更高效。
- ### 8. **限制[[回溯]]时的字符数**
  在使用量词时，可以通过指定最小和最大字符数来限制回溯。例如，使用 `\w{3,5}` 而不是 `\w+` 来匹配三到五个字母或数字。
- ### 9. **优化[[字符集]]**
  使用字符集时，避免重复和不必要的字符。例如，使用 `[a-z]` 而不是 `[a-zA-Za-z]`。