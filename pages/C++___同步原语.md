- C++ 提供了一系列同步原语（Synchronization Primitives），用于协调可能由多个线程并发执行而引起的竞态条件（Race Conditions）。这些原语能够帮助开发者在多线程程序中安全地访问共享数据，避免数据不一致性和其他并发相关的问题。以下是 C++ 中常见的同步原语，以及它们的基本用法和应用场景：
- ### 1. [[std::mutex]]
- **用途**：互斥量（Mutex）用于保护共享数据，防止同时由多个线程访问。
- **基本操作**：`lock()` 加锁，`unlock()` 解锁。
- **应用场景**：任何需要保证一次只有一个线程访问共享资源的场景。
- ### 2. [[std::recursive_mutex]]
- **用途**：递归互斥量允许同一个线程多次加锁。
- **基本操作**：`lock()` 加锁，`unlock()` 解锁。
- **应用场景**：用于递归函数中，当一个已锁定互斥量的线程需要再次请求锁时。
- ### 3. [[std::lock_guard]]
- **用途**：作用域锁（Scope Lock），自动管理互斥量的锁定和解锁过程。
- **基本操作**：构造时自动加锁，析构时自动解锁。
- **应用场景**：简化互斥量的锁定和解锁操作，避免因异常而漏解锁。
- ### 4. [[std::unique_lock]]
- **用途**：比 `std::lock_guard` 更灵活的作用域锁，支持延迟锁定、尝试锁定、条件变量等待等。
- **基本操作**：构造时可选择不立即锁定，支持`lock()`、`unlock()`，可与条件变量配合使用。
- **应用场景**：需要在同一作用域内多次锁定和解锁互斥量，或等待某个条件时。
- ### 5. [[std::shared_mutex]]（C++17）
- **用途**：读写锁，允许多个读操作同时进行，但写操作是独占的。
- **基本操作**：`lock_shared()` 加共享锁，`unlock_shared()` 解共享锁，`lock()` 加独占锁，`unlock()` 解独占锁。
- **应用场景**：读操作远多于写操作的共享数据保护。
- ### 6. [[std::condition_variable]]
- **用途**：条件变量，用于线程间的同步，允许线程在特定条件下挂起和唤醒。
- **基本操作**：`wait()` 等待条件，`notify_one()` 唤醒一个等待线程，`notify_all()` 唤醒所有等待线程。
- **应用场景**：生产者-消费者问题，或当线程需要等待某些条件成立才能继续执行时。
- ### 7. [[std::atomic]]
- **用途**：提供原子操作的类型封装，用于无锁编程。
- **基本操作**：原子类型的加载（`load`）、存储（`store`）和修改（如`fetch_add`）操作。
- **应用场景**：高性能并发编程，计数器，状态标志等。
- ### 8. [[std::semaphore]]（C++20）
- **用途**：计数信号量，用于控制对一组资源或资源池的访问。
- **基本操作**：`acquire()` 减少计数，`release()` 增加计数。
- **应用场景**：限制对资源数量有限的区域的并发访问，如数据库连接池管理。
-