- 翻译：C++[[源文件]]被[[编译器]]处理，大致按照顺序发生以下阶段：
  id:: 655a0c80-97fd-4492-9d22-218e10986b8c
- ## 阶段1
  id:: 655af3aa-ded9-46a3-b24c-fed1d22be9f3
  collapsed:: true
	- （自[[C++23]]起）编译器 保证支持 [[UTF-8]]代码单元序列（UTF-8 文件）的[[输入文件]]。支持的其他 输入文件类型集合 是由 *实现* 定义的。如果该 集合 非空，则 输入文件 的类型将以 实现 定义的方式确定，包括一种指定将输入文件指定为UTF-8文件的方式（识别字节顺序标记是不够的）。
		- 如果输入文件被确定为 UTF-8 文件，则它应是一个格式正确的 UTF-8 代码单元序列，并解码以产生 [[Unicode]]标量值序列。然后通过将每个 Unicode 标量值映射到相应的翻译字符集元素来形成翻译字符集元素序列。
		  #+BEGIN_NOTE
		  在结果序列中，由回车（U+000D）后跟换行（U+000A）组成的输入序列的每一对字符，以及每一个不紧随回车（U+000D）后跟换行（U+000A）的回车，将被替换为一个单一的[[换行字符]]。
		  #+END_NOTE
		- 对于 实现 支持的任何其他 输入文件 类型，字符将以 实现 定义的方式 映射到 翻译字符集元素的序列 。
		  特别是，依赖于 操作系统 的 换行符 将被替换为换行字符 。
- ## 阶段2
  collapsed:: true
	- 如果第一个翻译字符是[[byte order mark]]（U+FEFF），则删除它。（自C++23起）每当反斜杠出现在行尾时（紧随其后是零个或多个空格字符（不包括换行紧随其后（自C++23起）的换行字符）），这些字符将被删除，将两个物理源行组合成一个逻辑源行。这是一个单通道操作；以两个反斜杠结尾并紧跟空行的行不会将三行组合成一行。
	  logseq.order-list-type:: number
	  id:: 655a1c48-6aea-441b-9bcf-2d679cef23f7
	- 如果非空源文件在此步骤之后没有以换行字符结束（无论其原始状态如何，或者它以反斜杠紧跟的换行紧随其后结束），则添加一个终止的换行字符。
	  logseq.order-list-type:: number
- ## 阶段3
	- 源文件被分解为[[注释]]、[[空白字符]]序列（空格、水平制表符、换行、垂直制表符和换页符）以及[[预处理标记]]。
	  logseq.order-list-type:: number
	  [[预处理标记]]包括以下内容：
		- [[头文件]]名，如 `<iostream>` 或 `"myfile.h"`。
		  logseq.order-list-type:: number
		- 由预处理[[导入和模块指令]]（即 `import XXX;` 和 `module XXX;` ）产生的 *[[占位符]]标记*（自[[C++20]]起）。
		  logseq.order-list-type:: number
		- [[标识符]]。
		  logseq.order-list-type:: number
		  id:: 655a0cf4-3a00-4db4-b3f1-e3eb6f63bea1
		- *[[预处理]]数字* 。
		  logseq.order-list-type:: number
		- [[字符字面量]]，包括 用户定义 的 字符字面量。
		  logseq.order-list-type:: number
		- [[字符串字面量]]，包括 用户定义 的 字符串字面量。
		  logseq.order-list-type:: number
		- [[运算符]]和[[标点符号]]（包括 *替代标记* ），如 `+`、`<<=`、`<%`、`##` 或 `and`
		  logseq.order-list-type:: number
		- 不属于 其他类别 的 单个非空白字符。
		  logseq.order-list-type:: number
		  这样的字符与以下任一字符匹配，则程序格式错误：
			- 撇号（`'`, U+0027）。
			  logseq.order-list-type:: number
			- 引号（`"`, U+0022）。
			  logseq.order-list-type:: number
			- [[基本字符集]]外的字符。
			  logseq.order-list-type:: number
	- 在[[原始字符串字面量]]的初始和最终双引号之间，在 [阶段1](((655af3aa-ded9-46a3-b24c-fed1d22be9f3))) 进行的任何转换都将被还原。
	  logseq.order-list-type:: number
	- 每个[[注释]]都被替换为一个[[空格]]字符。
	  logseq.order-list-type:: number
	  id:: 655afa57-1854-493a-84a4-46506f7d9e38
	  保留[[换行符]]，未指明是否可以将非换行空白序列折叠为单个空格字符。
- 在形成下一个[[预处理标记]]（如不作为注释或其他形式的空白消耗的字符）时，识别并用[[翻译字符集]]的指定元素替换 通用字符名称 ，除非它们匹配以下字符序列中的一个：
	- [[字符字面量]]（c-char-sequence）
	  logseq.order-list-type:: number
	- [[字符串字面量]]（s-char-sequence 和 r-char-sequence），不包括[[分隔符]]（d-char-sequence）
	  logseq.order-list-type:: number
	- [[头文件]]名（h-char-sequence 和 q-char-sequence）（自 C++23 起）
	  logseq.order-list-type:: number
- 如果输入已被解析为[[预处理标记]]直到给定字符，那么下一个 预处理标记 通常被认为是可以构成 预处理字符 的最长字符序列，即使这样会导致后续分析失败。这通常被称为最大匹配规则。
  
  例子：
  ```
  int foo = 1;
  int bar = 0xE+foo;   // 错误，无效的预处理数字 0xE+foo
  int baz = 0xE + foo; // 正确
  
  int quux = bar+++++baz; // 错误：bar++ ++ +baz，而不是 bar++ + ++baz。
  ```
  最大匹配规则的唯一例外是：
	- 如果下一个字符开始的字符序列可以是原始字符串字面量的前缀和初始双引号，那么下一个预处理令牌应是一个原始字符串字面量。字面量包含与原始字符串模式匹配的最短字符序列。
	  logseq.order-list-type:: number
	- 如果接下来的三个字符是 `<::` 且后续字符既不是 `:` 也不是 `>`，则 `<` 被视为一个预处理令牌（而不是替代令牌 `<:` 的第一个字符）。
	  logseq.order-list-type:: number
	- 在 `#include` 或 `import`（自 C++20 起）指令中，或在 `__has_include` 表达式中（自 C++17 起），才会形成头文件名预处理令牌。
	  logseq.order-list-type:: number
	- ### 第四阶段
	  logseq.order-list-type:: number
	  1. 执行预处理器。
	  2. 使用 `#include` 指令引入的每个文件都递归地经过第一阶段到第四阶段。
	  3. 在此阶段结束时，所有预处理器指令都从源代码中移除。
	- ### 第五阶段
	  logseq.order-list-type:: number
	  1. 字符字面量和字符串字面量中的所有字符都从源字符集转换为编码（可以是多字节字符编码，如 UTF-8，只要基本字符集的 96 个字符都有单字节表示）。
	  2. 字符字面量和非原始字符串字面量中的转义序列和通用字符名称被展开并转换为字面量编码。如果通用字符名称指定的字符不能在相应的字面量编码中编码为单个代码点，则结果是实现定义的，但保证不是空（宽）字符。
	  
	   注意：在某些实现中，此阶段的转换可以通过命令行选项控制：gcc 和 clang 使用 `-finput-charset` 指定源字符集的编码，`-fexec-charset` 和 `-fwide-exec-charset` 分别指定普通和宽字面量的编码，而 Visual Studio 2015 更新 2 及更高版本使用 `/source-charset` 和 `/execution-charset` 分别指定源字符集和字面量编码。（直到 C++23）
	  
	   对于两个或多个相邻的字符串字面量令牌序列，确定一个共同的编码前缀，然后认为每个这样的字符串字面量令牌都有那个共同的编码前缀。（字符转换移至第三阶段）（自 C++23 起）
	- ### 第六阶段
	  logseq.order-list-type:: number
	  相邻的字符串字面量被连接。
	- ### 第七阶段
	  logseq.order-list-type:: number
	  编译发生：每个预处理令牌被转换为一个令
	  
	  牌。这些令牌在语法上和语义上进行分析和翻译，作为一个翻译单元。
	- ### 第八阶段
	  logseq.order-list-type:: number
	  每个翻译单元被检查以生成所需模板实例化的列表，包括通过显式实例化请求的实例化。定位模板的定义，并执行所需的实例化以产生实例化单元。
	- ### 第九阶段
	  logseq.order-list-type:: number
	  翻译单元、实例化单元和为满足外部引用而需要的库组件被收集到一个程序映像中，该程序映像包含在其执行环境中执行所需的信息。