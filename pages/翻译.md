- 翻译：C++[[源文件]]被[[编译器]]处理，大致按顺序发生以下阶段：
  id:: 655a0c80-97fd-4492-9d22-218e10986b8c
- ## 阶段1
  id:: 655af3aa-ded9-46a3-b24c-fed1d22be9f3
	- （自[[C++23]]起）编译器 保证支持 [[UTF-8]]代码单元序列（UTF-8 文件）的[[输入文件]]。支持的其他 输入文件类型集合 是由 *实现* 定义的。如果该 集合 非空，则 输入文件 的类型将以 实现 定义的方式确定，包括一种指定将输入文件指定为UTF-8文件的方式（识别字节顺序标记是不够的）。
		- 如果输入文件被确定为 UTF-8 文件，则它应是一个格式正确的 UTF-8 代码单元序列，并解码以产生 [[Unicode]]标量值序列。然后通过将每个 Unicode 标量值映射到相应的翻译字符集元素来形成翻译字符集元素序列。
		  #+BEGIN_NOTE
		  在结果序列中，由回车（U+000D）后跟换行（U+000A）组成的输入序列的每一对字符，以及每一个不紧随回车（U+000D）后跟换行（U+000A）的回车，将被替换为一个单一的[[换行字符]]。
		  #+END_NOTE
		- 对于 实现 支持的任何其他 输入文件 类型，字符将以 实现 定义的方式 映射到 翻译字符集元素的序列 。
		  特别是，依赖于 操作系统 的 换行符 将被替换为换行字符 。
- ## 阶段2
	- 如果第一个翻译字符是[[byte order mark]]（U+FEFF），则删除它。（自C++23起）每当反斜杠出现在行尾时（紧随其后是零个或多个空格字符（不包括换行紧随其后（自C++23起）的换行字符）），这些字符将被删除，将两个物理源行组合成一个逻辑源行。这是一个单通道操作；以两个反斜杠结尾并紧跟空行的行不会将三行组合成一行。
	  logseq.order-list-type:: number
	  id:: 655a1c48-6aea-441b-9bcf-2d679cef23f7
	- 如果非空源文件在此步骤之后没有以换行字符结束（无论其原始状态如何，或者它以反斜杠紧跟的换行紧随其后结束），则添加一个终止的换行字符。
	  logseq.order-list-type:: number
- ## 阶段3
	- 源文件被分解为[[注释]]、[[空白字符]]序列（空格、水平制表符、换行、垂直制表符和换页符）以及[[预处理标记]]。
	  logseq.order-list-type:: number
	  [[预处理标记]]包括以下内容：
		- [[头文件]]名，如 `<iostream>` 或 `"myfile.h"`。
		  logseq.order-list-type:: number
		- 由预处理[[导入和模块指令]]（即 `import XXX;` 和 `module XXX;` ）产生的 *[[占位符]]标记*（自[[C++20]]起）。
		  logseq.order-list-type:: number
		- [[标识符]]。
		  logseq.order-list-type:: number
		  id:: 655a0cf4-3a00-4db4-b3f1-e3eb6f63bea1
		- *[[预处理]]数字* 。
		  logseq.order-list-type:: number
		- [[字符字面量]]，包括 用户定义 的 字符字面量。
		  logseq.order-list-type:: number
		- [[字符串字面量]]，包括 用户定义 的 字符串字面量。
		  logseq.order-list-type:: number
		- [[运算符]]和[[标点符号]]（包括 *替代标记* ），如 `+`、`<<=`、`<%`、`##` 或 `and`
		  logseq.order-list-type:: number
		- 不属于 其他类别 的 单个非空白字符。
		  logseq.order-list-type:: number
		  这样的字符与以下任一字符匹配，则程序格式错误：
			- 撇号（`'`, U+0027）。
			  logseq.order-list-type:: number
			- 引号（`"`, U+0022）。
			  logseq.order-list-type:: number
			- [[基本字符集]]外的字符。
			  logseq.order-list-type:: number
	- 在[[原始字符串字面量]]的初始和最终双引号之间，在 [阶段1](((655af3aa-ded9-46a3-b24c-fed1d22be9f3))) 进行的任何转换都将被还原。
	  logseq.order-list-type:: number
	- 每个[[注释]]都被替换为一个[[空格]]字符。
	  logseq.order-list-type:: number
	  id:: 655afa57-1854-493a-84a4-46506f7d9e38
	  保留[[换行符]]，未指明是否可以将非换行空白序列折叠为单个空格字符。
- 在形成下一个[[预处理标记]]（如不作为注释或其他形式的空白消耗的字符）时，识别并用[[翻译字符集]]的指定元素替换 通用字符名称 ，除非它们匹配以下字符序列中的一个：
	- [[字符字面量]]（c-char-sequence）
	  logseq.order-list-type:: number
	- [[字符串字面量]]（s-char-sequence 和 r-char-sequence），不包括[[分隔符]]（d-char-sequence）
	  logseq.order-list-type:: number
	- [[头文件]]名（h-char-sequence 和 q-char-sequence）（自 C++23 起）
	  logseq.order-list-type:: number
- 如果输入已被解析为[[预处理标记]]直到给定字符，那么下一个 预处理标记 通常被认为是可以构成 预处理字符 的最长字符序列，即使这样会导致后续分析失败。这通常被称为最大匹配规则。
  例子：
  ``` cpp
  int foo = 1;
  int bar = 0xE+foo;   // 错误，无效的预处理数字 0xE+foo
  int baz = 0xE + foo; // 正确
  
  int quux = bar+++++baz; // 错误：bar++ ++ +baz，而不是 bar++ + ++baz。
  ```
- 最大匹配规则的唯一例外是：
	- 如果下一个字符开始的字符序列可以是原始字符串字面量的前缀和初始双引号，那么下一个预处理标记应是一个原始字符串字面量。字面量包含与原始字符串模式匹配的最短字符序列。
	  logseq.order-list-type:: number
	- 如果接下来的三个字符是 `<::` 且后续字符既不是 `:` 也不是 `>`，则 `<` 被视为一个预处理标记（而不是替代令牌 `<:` 的第一个字符）。
	  logseq.order-list-type:: number
	- 在 `#include` 或 `import`（自 C++20 起）指令中，或在 `__has_include` 表达式中（自 C++17 起），才会形成头文件名预处理标记。
	  logseq.order-list-type:: number
- ## 阶段4
	- 执行[[预处理器]]。
	  logseq.order-list-type:: number
	- 使用[[#include 指令]]引入的每个文件都递归地经过 [阶段1](((655af3aa-ded9-46a3-b24c-fed1d22be9f3))) 到 阶段4 。
	  logseq.order-list-type:: number
	- 在此阶段结束时，所有[[预处理器指令]]都从源代码中移除。
	  logseq.order-list-type:: number
- ## 阶段5
	- 对于两个或多个相邻的 [[字符串字面量]]标记序列，确定一个共同的 编码前缀 ，然后认为每个这样的 字符串字面量标记 都有那个共同的 编码前缀 。（自 C++23 起）
	  logseq.order-list-type:: number
- ## 阶段6
	- 相邻的[[字符串字面量]]被连接。
- ## 阶段7
  id:: 655afacb-82dd-4390-86ad-f073d7faca44
	- [[编译]]发生：每个[[预处理标记]]被转换为一个[[标记]]。这些 标记 在[[语法]]上和[[语义]]上进行 分析 和[[翻译]]，作为一个[[翻译单元]]。
- ## 阶段8
	- 每个[[翻译单元]]被检查以生成所需[[模板实例化]]的列表，包括通过[[显式实例化]]请求的实例化。
	  定位[[模板]]的定义，并执行所需的 实例化 以产生[[instantiation unit]]。
- ## 阶段9
  id:: 655afacb-457a-4813-a946-9d879858f81b
	- [[翻译单元]]、[[实例化单元]] 和 为满足[[外部引用]]而需要的[[库组件]] 被收集到一个[[程序映像]]中，该 程序映像 包含在其[[执行环境]]中 执行 所需的信息。
- 一些[[编译器]]并未实现[[实例化单元]]（也称为[[模板库]]或[[模板注册表]]），而是在 [阶段7](((655afacb-82dd-4390-86ad-f073d7faca44))) 简单地编译每个[[模板实例化]]，将代码存储在 隐式 或 显式 请求它的[[目标文件]]中，然后[[链接器]]在 [阶段9](((655afacb-457a-4813-a946-9d879858f81b))) 将这些 编译好的实例化 合并为一个。
-