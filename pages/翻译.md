- 翻译：C++[[源文件]]被[[编译器]]处理，大致按照顺序发生以下阶段：
  id:: 655a0c80-97fd-4492-9d22-218e10986b8c
- ## 阶段1
	- （自[[C++23]]起）编译器 保证支持 [[UTF-8]]代码单元序列（UTF-8 文件）的[[输入文件]]。支持的其他 输入文件类型集合 是由 *实现* 定义的。如果该 集合 非空，则 输入文件 的类型将以 实现 定义的方式确定，包括一种指定将输入文件指定为UTF-8文件的方式（识别字节顺序标记是不够的）。
		- 如果输入文件被确定为 UTF-8 文件，则它应是一个格式正确的 UTF-8 代码单元序列，并解码以产生 [[Unicode]]标量值序列。然后通过将每个 Unicode 标量值映射到相应的翻译字符集元素来形成翻译字符集元素序列。
		  #+BEGIN_NOTE
		  在结果序列中，由回车（U+000D）后跟换行（U+000A）组成的输入序列的每一对字符，以及每一个不紧随回车（U+000D）后跟换行（U+000A）的回车，将被替换为一个单一的[[换行字符]]。
		  #+END_NOTE
		- 对于 实现 支持的任何其他 输入文件 类型，字符将以 实现 定义的方式 映射到 翻译字符集元素的序列 。
		  特别是，依赖于 操作系统 的 换行符 将被替换为换行字符 。
- ## 阶段2
	- 如果第一个翻译字符是[[byte order mark]]（U+FEFF），则删除它。（自C++23起）每当反斜杠出现在行尾时（紧随其后是零个或多个空格字符（不包括换行紧随其后（自C++23起）的换行字符）），这些字符将被删除，将两个物理源行组合成一个逻辑源行。这是一个单通道操作；以两个反斜杠结尾并紧跟空行的行不会将三行组合成一行。
	  logseq.order-list-type:: number
	  id:: 655a1c48-6aea-441b-9bcf-2d679cef23f7
	- 如果非空源文件在此步骤之后没有以换行字符结束（无论其原始状态如何，或者它以反斜杠紧跟的换行紧随其后结束），则添加一个终止的换行字符。
	  logseq.order-list-type:: number
- ## 阶段3
	- 源文件被分解为[[注释]]、[[空白字符]]序列（空格、水平制表符、换行、垂直制表符和换页符）以及[[预处理标记]]。
	  logseq.order-list-type:: number
	  [[预处理标记]]包括以下内容：
		- [[头文件]]名，如 `<iostream>` 或 `"myfile.h"`
		  logseq.order-list-type:: number
		- 由预处理[[导入和模块指令]]（即 `import XXX;` 和 `module XXX;` ）产生的 *[[占位符]]标记*（自[[C++20]]起）。
		  logseq.order-list-type:: number
		- [[标识符]]
		  logseq.order-list-type:: number
		  id:: 655a0cf4-3a00-4db4-b3f1-e3eb6f63bea1
		- 预处理数
		  logseq.order-list-type:: number
	- 字符字面值，包括用户定义的字符字面值（自C++11起）
	- 字符串字面值，包括用户定义的字符串字面值（自C++11起）
	- 操作符和标点符号（包括替代标记），如+、<<=、<%、##或和
	- 不适用于任何其他类别的个体非空白字符
	  如果与此类别匹配的字符是
		- 撇号（'，U+0027），
		- 引号（"，U+0022），或
		- 不在基本字符集中的字符，
		  则程序是非法的。
		  2) 在第1和（自C++23起）最终双引号之间的任何原始字符串字面值的
		  
		  初始和最终双引号之间执行的任何转换都将被还原。（自C++11起）
		  3) 每个注释都被一个空格字符替换。换行保留，非换行空白序列是否可以折叠成单个空格字符是未指定的。
		  
		  在从源文件中获取下一个预处理标记（即未作为注释或其他形式的空白的一部分而被消耗的字符）的过程中，通用字符名称将被识别并替换为翻译字符集的指定元素，除非在以下情况下匹配字符序列：
	- 字符字面值（c-char-sequence）
	- 字符串字面值（s-char-sequence和r-char-sequence），不包括定界符（d-char-sequence）
	- 用于包含的文件名（h-char-sequence和q-char-sequence）（自C++23起）
	  如果输入已被解析为包含给定字符的预处理标记，则通常认为下一个预处理标记是可以构成预处理标记的字符的最长序列，即使这将导致随后的分析失败。这通常被称为“最大吞噬”。
	  
	  ```cpp
	  int foo = 1;
	  int bar = 0xE+foo;   // 错误，无效的预处理数0xE+foo
	  int baz = 0xE + foo; // 正确
	  
	  int quux = bar+++++baz; // 错误：bar++ ++ +baz，而不是bar++ + ++baz。
	  ```
	  
	  唯一的例外是：
- 如果下一个字符开始一个可以是原始字符串字面值的前缀和初始双引号的字符序列，则下一个预处理标记应该是原始字符串字面值。该字面量由与原始字符串模式匹配的最短字符序列组成。
  
  ```cpp
  #define R "x"
  const char* s = R"y";        // 非法的原始字符串字面值，不是"x" "y"
  const char* s2 = R"(a)" "b)"; // 一个原始字符串字面值后面跟着一个普通字符串字面值
  ```
- 如果下三个字符是<::，并且随后的字符既不是:也不是>，则<将被视为一个预处理标记（而不是替代标记<:的第一个字符）。
  
  ```cpp
  struct Foo { static const int v = 1; };
  std::vector<::Foo> x;    // 正确，<:不作为[的替代标记
  extern int y<::>;        // 正确，与extern int y[]相同。
  int z<:::Foo::value:>;    // 正确，int z[::Foo::value];
  ```
  
  （自C++11起）
- 头文件预处理标记仅在#include或import（自C++20起）指令中形成，或在__has_include表达式（自C++17起）中形成。
  
  ```cpp
  std::vector<int> x; // 正确，<int>不是头文件名
  ```
- #### 阶段4
  1) 执行预处理器。
  2) 通过阶段1到4递归地处理每个由#include指令引入的文件。
  3) 在此阶段结束时，从源中移除所有预处理指令。
- #### 阶段5
  1) 将字符字面值和字符串字面值中的所有字符从源字符集转换为编码（可以是多字节字符编码，例如UTF-8，只要基本字符集的96个字符具有单字节表示）。
  2) 字符字面值和非原始字符串字面值中的转义序列和通用字符名称将被扩展并转换为文字编码。如果通用字符名称指定的字符不能以相应的文字编码中的单个代码点编码，则结果是实现定义的，但保证不是空（宽）字符。
  
  注意：在某些实现中，此阶段执行的转换可以通过命令行选项进行控制：gcc和clang使用-finput-charset指定源字符集的编码，-fexec-charset和-fwide-exec-charset指定普通和宽面文字编码，而Visual Studio 2015 Update 2及更高版本使用/source-charset和/execution-charset指定源字符集和文字编码。
  
  （自C++23起）
  对于两个或两个以上相邻的字符串字面值标记，将确定一个公共的编码前缀，如