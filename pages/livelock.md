alias:: 活锁

- 活锁（Livelock）是并发编程中的一种特殊情况，其中两个或多个执行实体（如线程或进程）无限期地重复相同的交互，而没有任何实际进展。与死锁（Deadlock）不同，死锁中涉及的线程或进程处于等待状态，不再执行任何操作；而在活锁的情况下，执行实体持续活跃地执行，但这些操作仅仅导致它们返回到原始状态，无法向前推进任务的完成。
- ### 活锁的产生
  
  活锁通常发生在两个或多个线程试图通过**相互让步**来解决冲突的场景中。每个线程都试图避免与其他线程的冲突，但它们的解决方案却导致了无限循环，因为它们反复尝试相同的解决方案。
- ### 活锁示例
  
  考虑两个线程或进程，它们都试图获取相同的两个资源，当发现对方也在尝试获取资源时，它们各自释放已持有的资源并稍后重试，希望对方能成功获取资源。然而，如果它们的重试策略完全相同，它们可能会**无限期地交换资源**，而没有任何一方能够同时获取到所有必需的资源。
- ### 活锁与死锁的区别
- **死锁**：线程或进程处于完全停止状态，等待永远不会满足的条件（例如，等待被另一个已停止的线程持有的锁）。
- **活锁**：线程或进程保持活跃状态，但它们的操作仅仅导致状态重复，无法完成实际工作。
- ### 解决活锁
  
  解决活锁的关键在于引入随机性或改变线程重试操作的策略，以打破无限重试的循环。一些策略包括：
- **随机等待**：在再次尝试之前引入随机等待时间，以减少线程间的同步尝试冲突。
- **退避策略**：在连续失败尝试后逐渐增加等待时间（指数退避或其他退避策略）。
- **状态变化**：改变线程重试或操作的顺序或方式，以避免重复相同的失败模式。
-