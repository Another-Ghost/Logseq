alias:: 活锁

- 活锁（Livelock）是并发编程中的一种特殊情况，其中两个或多个执行实体（如线程或进程）无限期地重复相同的交互，而没有任何实际进展。与[[死锁]]（Deadlock）不同，死锁中涉及的线程或进程处于等待状态，不再执行任何操作；而在活锁的情况下，执行实体持续活跃地执行，但这些操作仅仅导致它们返回到原始状态，无法向前推进任务的完成。
- ### 活锁的产生
  活锁通常发生在两个或多个线程试图通过**相互让步**来解决冲突的场景中。每个线程都试图避免与其他线程的冲突，但它们的解决方案却导致了无限循环，因为它们反复尝试相同的解决方案。
- ### 活锁示例
  考虑两个线程或进程，它们都试图获取相同的两个资源，当发现对方也在尝试获取资源时，它们各自释放已持有的资源并稍后重试，希望对方能成功获取资源。然而，如果它们的重试策略完全相同，它们可能会**无限期地交换资源**，而没有任何一方能够同时获取到所有必需的资源。
- ### 活锁与死锁的区别
	- **死锁**：线程或进程处于完全停止状态，等待永远不会满足的条件（例如，等待被另一个已停止的线程持有的锁）。
	- **活锁**：线程或进程保持活跃状态，但它们的操作仅仅导致状态重复，无法完成实际工作。
	  两种情形的关键区别在于，这里发生的等待并非^^阻塞型等待^^，而是处于活动状态的检测循环，比如自旋锁。如果情况严重，活锁的表现与死锁相同 (应用软件停滞不前)。但不同之处是，活锁令 CPU 占用率居高不下，因为牵涉的线程其实还都在运行，只不过互相阻碍着对方。
	  而在不严重的情况 下，活锁最终会因线程的随机调度而被解开。尽管这样，活锁仍会长久阻塞它所牵涉的任务，还会在此期间严重占用CPU。
- ### 解决活锁
  解决活锁的关键在于引入随机性或改变线程重试操作的策略，以打破无限重试的循环。一些策略包括：
	- **随机等待**：在再次尝试之前引入随机等待时间，以减少线程间的同步尝试冲突。
	- **退避策略**：在连续失败尝试后逐渐增加等待时间（指数退避或其他退避策略）。
	- **状态变化**：改变线程重试或操作的顺序或方式，以避免重复相同的失败模式。
-