alias:: 内存的映射, memory mapping

- [[Linux]]通过将一个[[虚拟内存区域]]与一个[[磁盘]]上的[[目标文件]](object file)关联起来，以初始化这个虚拟内存区域的内容，这个过程称为[[内存映射]]。虚拟内存区域可以映射到两种类型的[[对象]]中的一种：
	- [[Linux 文件系统]]中的[[普通文件]]：一个区域可以映射到一个普通磁盘文件的**连续**部分，例如一个[[可执行目标文件]]。
	  [[file section]]被分成[[页]]大小的[[片]]，每一[[片]]包含一个[[虚拟页面]]的初始内容。因为[按需进行页面调度]([[按需页面调度]])，所以这些[[虚拟页面]]没有实际交换进入 物理内存 ，直到 CPU**第一次引用到页面**（即发射一个 虚拟地址 ，落在 虚拟地址空间 这个页面的范围之内）。如果 区域 比[[file section]]要大，那么就用零来填充这个区域的余下部分。
	- [[匿名文件]]：一个[区域]([[虚拟内存区域]])也可以映射到一个[[匿名文件]]，匿名文件是由[[内核]]创建的，包含的全是二进制 $0$ 。 CPU第一次引用这样一个区域内的虚拟页面时，内核就在物理内存中找到一个合适的牺牲页面，如果该页面被修改过，就将这个页面换出来，用二进制 0 覆盖牺牲页面并更新[[页表]]，将这个页面标记为是驻留在内存中的。
	  注意在[[磁盘]]和[[内存]]之间**并没有实际的数据传送**。因为这个原因，映射到匿名文件的区域中的页面有时也叫做 请求二进制零的页([[demand-zero page]])。
- 无论在哪种情况中，一旦一个[[虚拟页面]]被初始化了，它就在一个由[[内核]]维护的专门的[[交换文件]](swap file)之间换来换去。[[交换文件]]也叫做[[交换空间]](swap space)。
  需要意识到的很重要的一点是，在任何时刻，[[交换空间]]都限制着当前运行着的[[进程]]能够分配的[[虚拟页面]]的**总数**。
- [[Linux]]提供一个称为[[mmap]]的[[系统调用]]，允许[[应用程序]]自己做内存映射。
- # [[共享目标]]
	- 正如我们已经看到的，进程 这一抽象能够为每个进程提供自己私有的虚拟地址空间，可以免受其他进程的错误读写。
	  不过，许多进程有**相同的只读代码区域**。例如，每个运行 Linux shell 程序 bash 的进程都有相同的代码区域。而且，许多程序需要访问[[只读运行时库]]代码的**相同副本**。例如，每个 C程序 都需要来自 标准C库 的诸如 `printf` 这样的函数。
	  那么，如果每个进程都在 物理内存 中保持这些常用代码的副本，那就是极端的浪费了。幸运的是，[[内存映射]]给我们提供了一种清晰的机制，用来控制多个[[进程]]如何[[共享目标]]。
	- 一个[[目标]]可以被[映射]([[内存映射]])到[[虚拟内存]]的一个[区域]([[虚拟内存区域]])，要么作为[[共享目标]]，要么作为[[私有目标]]。
		- 如果一个进程将一个[[共享目标]]映射到它的虚拟地址空间的一个区域内，那么这个进程对这个区域的任何写操作，对于那些也把这个[[共享目标]]映射到它们虚拟内存的 其他进程 而言，也是[[可见的]]。
		- 而且，这些变化也会反映在[[磁盘]]上的[[原始目标]]中。另一方面，对于一个映射到[[私有目标]]的区域做的改变，对于其他进程来说是不可见的，并且进程对这个区域所做的任何写操作都不会反映在磁盘上的对象中。一个映射到共享对象的虚拟内存区域叫做共享区域。类似地，也有私有区域。