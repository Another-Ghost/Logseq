alias:: 内存序, memory ordering, 内存顺序

- 对[[原子类型]]的操作可以应用六种 *内存排序* 选项：
	- `memory_order_relaxed`
	  logseq.order-list-type:: number
	- `memory_order_consume`
	  logseq.order-list-type:: number
	- `memory_order_acquire`
	  logseq.order-list-type:: number
	- `memory_order_release`
	  logseq.order-list-type:: number
	- `memory_order_acq_rel`
	  logseq.order-list-type:: number
	- `memory_order_seq_cst`
	  logseq.order-list-type:: number
- 除非为特定操作另行指定，否则所有原子类型操作的内存排序选项默认为[[memory_order_seq_cst]]，这是所有可用选项中最严格的。
  虽然有六种排序选项，但它们代表了三种模型：
	- [[顺序一致性排序]]([[memory_order_seq_cst]]),
	- [[获取-释放排序]]([[memory_order_consume]], [[memory_order_acquire]], [[memory_order_release]]和[[memory_order_acq_rel]]),
	- [[宽松排序]]([[memory_order_relaxed]])。
- 这些不同的内存排序模型在不同的CPU架构上可能会有不同的成本。
	- 例如，在基于那些能够精细控制[[操作可见性]]的架构的系统上，相比于获取-释放排序或宽松排序，顺序一致性排序可能需要额外的同步指令；而相比于宽松排序，获取-释放排序也是如此。如果这些系统有许多处理器，这些额外的同步指令可能需要相当一部分时间，从而降低系统的整体性能。
	- 另一方面，使用x86或x86_64架构的CPU不需要为获取-释放排序提供任何额外的指令，这些指令仅仅是为了确保原子性所必需的，甚至顺序一致性排序也不需要对加载操作进行任何特殊处理，尽管在存储操作上有一点额外的成本。
- 不同内存排序模型的可用性允许专家利用更[[细粒度]]排序关系来提升性能，同时允许在不太关键的情况下使用默认的[[顺序一致性排序]]（比其他排序更容易推理）。
- #+BEGIN_TIP
  为了选择使用哪种排序模型，或理解使用不同模型的代码中的排序关系，了解这些选择如何影响程序行为是很重要的。因此，让我们看看每个选择对操作排序和`synchronizes-with`的后果。
  #+END_TIP
- ## [[顺序一致性排序]]
	-