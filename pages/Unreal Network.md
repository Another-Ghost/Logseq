id:: 6530f3ac-b908-43ce-94f6-6096bdaac577
>[[客户端]]是对[[服务端]]的拙劣模仿。
这句话的意思是说，客户端自己也同样运行着一个世界，并不断预测服务端的行为。从而不断更新当前世界，以最大程度地接近 服务端的世界。
这就是说，我们承认“延迟”客观存在，只要我们的客户端模仿得别太差劲，那么玩家是可以接受这样的效果的。客户端可以根据同步数据发送时的当前对象的位置与速度，加上数据发送的时间，猜测出当前对象在服务端的可能位置。并且通过修正当前世界（比如调整当前对象的速度方向，指向新的位置），去模仿服务端位置。如果服务端的位置和客户端差距太大，就强行闪现修正。

- ## 使用建议
	- 尽可能少用[[RPC]]。在合适情况下改用[[RepNotify]]。
	- 组播函数会导致会话中各连接客户端的额外网络流量，需尤其少用。
	- -
	- 若能保证非复制函数仅在服务器上执行，则服务器RPC中无需包含纯服务器逻辑。
	- -
	- 将可靠RPC绑定到玩家输入时需谨慎。玩家可能会快速反复点击按钮，导致可靠RPC队列溢出。应采取措施限制玩家激活此项的频率。
	- -
	- 若游戏频繁调用RPC或复制函数，如tick时，则应将其设为不可靠。
	- -
	- 部分函数可重复使用。调用其响应游戏逻辑，然后调用其响应RepNotify，确保客户端和服务器拥有并列执行即可。
	- -
	- 检查Actor的网络角色可查看其是否为 `ROLE_Authority`。此方法适用于过滤函数中的执行，该函数同时在服务器和客户端上激活。
	- -
	- 使用C++中的 `IsLocallyControlled` 函数或蓝图中的Is Locally Controlled函数，可检查Pawn是否受本地控制。基于执行是否与拥有客户端相关来过滤函数时，此方法十分拥有。
	- -
	- 构造期间Pawn可能未被指定控制器，因此避免在构造函数脚本中使用 `IsLocallyControlled`。