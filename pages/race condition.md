alias:: 竞态条件, 竞争条件, 条件竞争

-
- 编写使用并发的软件的大部分复杂性来自于避免问题性的竞态条件。
- 竞态条件（Race Condition）是[[并发编程]]中一个常见的问题，当两个或多个[[线程]]在没有适当[[同步]]的情况下访问共享资源，并且**至少有一个线程修改这些资源**时发生。竞态条件会导致程序输出不可预测的结果，因为**线程的执行顺序**可能会影响最终状态。
- 大多数时候，这是相当良性的，因为所有可能的结果都是可以接受的，尽管它们可能会随着不同的相对顺序而改变。
  例如，如果两个线程正在向队列中添加项目进行处理，通常不关心哪个项目先被添加，只要系统的[[不变性]]得到维护。当竞态条件导致不变性破裂时，就会出现问题，比如提到的双向链表示例。
  在谈论并发时，竞态条件一词通常用来指代有问题的竞态条件。
- C++标准还定义了[[数据竞争]]这个术语，意指由于对单个对象的并发修改而引起的特定类型的[[竞态条件]]；数据竞态会导致未定义行为。
- ### 竞态条件的特点
	- **不确定性**：由于线程调度的不确定性，程序的执行结果可能随每次运行而变化。
	  > 问题性的竞态条件通常发生在完成一个操作需要修改两个或更多不同的数据段的地方。因为操作必须访问两个独立的数据段，这些必须在不同的指令中进行修改，而另一个线程可能在其中一个完成时就访问了数据结构。竞态条件往往很难找到，也很难复制，因为[[机会窗口]]很小。如果 修改 作为 连续的CPU指令 来完成，那么问题在任何一次运行中出现的机会都很小，即使数据结构正在被另一个线程同时访问。随着系统负载的增加，以及操作执行次数的增加，问题执行序列发生的机会也会增加。这种问题几乎肯定会在最不方便的时候出现。
	- **依赖时序**：正确的执行结果错误地依赖于线程的执行顺序或时序。
	- **难以重现和调试**：**因为竞态条件通常与时间敏感，所以当应用程序在调试器下运行时，它们通常会完全消失，因为[[调试器]]会影响程序的时间，即使只是稍微影响**。
- ### 竞态条件的例子
  
  考虑两个线程同时更新同一个全局计数器的简单示例：
  
  ```cpp
  int counter = 0;
  
  void increment() {
    int temp = counter; // 读取全局计数器
    temp = temp + 1;    // 增加局部副本
    counter = temp;     // 写回全局计数器
  }
  
  // 假设两个线程同时执行increment函数
  ```
  
  如果两个线程几乎同时执行这个函数，它们可能读取相同的`counter`值，分别增加，然后将它们的结果（实际上是相同的值）写回`counter`。这意味着`counter`实际上只增加了1，而不是2，导致了数据的不一致性。
- ### 避免竞态条件
	- **使用互斥锁**：通过互斥锁（Mutexes）保护对共享资源的访问，确保任何时候只有一个线程能访问资源。
	- **原子操作**：使用原子操作来更新共享变量，这些操作保证了操作的原子性和顺序性。
	- **条件变量**：使用条件变量同步线程间的操作顺序，确保在满足特定条件前不进行操作。
	- **设计无锁数据结构**：通过无锁（Lock-Free）或无等待（Wait-Free）数据结构避免竞态条件，这些结构利用原子操作来保证数据一致性。
	- 另一种方式是将数据结构的更新处理为一个[[transaction]]，就像数据库的更新在事务中完成一样。所需的一系列数据修改和读取被存储在事务日志中，然后在一个步骤中提交。如果因为数据结构已经被另一个线程修改而无法提交，那么事务就会重新开始。这被称为[[软件事务内存]].
	  >C++没有直接支持STM（尽管C++有事务内存扩展的技术规范）  。
-