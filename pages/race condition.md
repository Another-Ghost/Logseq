alias:: 竞态条件, 竞争条件

- 在[[并发]]中，[[竞态条件]]是指结果取决于两个或更多线程上的**操作执行顺序**的任何东西；线程争相执行各自的操作。
- 大多数时候，这是相当良性的，因为所有可能的结果都是可以接受的，尽管它们可能会随着不同的相对顺序而改变。
  例如，如果两个线程正在向队列中添加项目进行处理，通常不关心哪个项目先被添加，只要系统的[[不变性]]得到维护。当竞态条件导致不变性破裂时，就会出现问题，比如提到的双向链表示例。
  在谈论并发时，竞态条件一词通常用来指代有问题的竞态条件。
- C++标准还定义了[[数据竞争]]这个术语，意指由于对单个对象的并发修改而引起的特定类型的[[竞态条件]]；数据竞态会导致未定义行为。
- 问题性的竞态条件通常发生在完成一个操作需要修改两个或更多不同的数据段的地方。因为操作必须访问两个独立的数据段，这些必须在不同的指令中进行修改，而另一个线程可能在其中一个完成时就访问了数据结构。竞态条件往往很难找到，也很难复制，因为 机会窗口 很小。如果 修改 作为 连续的CPU指令 来完成，那么问题在任何一次运行中出现的机会都很小，即使数据结构正在被另一个线程同时访问。随着系统负载的增加，以及操作执行次数的增加，问题执行序列发生的机会也会增加。这种问题几乎肯定会在最不方便的时候出现。**因为竞态条件通常与时间敏感，所以当应用程序在调试器下运行时，它们通常会完全消失，因为[[调试器]]会影响程序的时间，即使只是稍微影响**。
- 编写使用并发的软件的大部分复杂性来自于避免问题性的竞态条件。
- ### 避免问题性的竞态条件
	- 有几种方法可以处理棘手的竞态条件。
		- 最简单的选项是用 *保护机制* 包装你的数据结构，确保**只有执行修改的线程可以看到[[不变量]]被破坏的中间状态**。
		  从访问该数据结构的其他线程的角度来看，这样的修改要么还没开始，要么已经完成。
		- 另一种选择是修改你的数据结构和其[[不变量]]的设计，使得修改作为一系列不可分割的变化进行，每一种变化都保持不变量。这通常被称为[[无锁编程]]，一般很难做到正确。如果你在这个层面上工作，内存模型的细微差别和识别哪些线程可能看到哪一组值可能会变得复杂。
		- 另一种方式是将数据结构的更新处理为一个[[transaction]]，就像数据库的更新在事务中完成一样。所需的一系列数据修改和读取被存储在事务日志中，然后在一个步骤中提交。如果因为数据结构已经被另一个线程修改而无法提交，那么事务就会重新开始。这被称为[[软件事务内存]].
		  >C++没有直接支持STM（尽管C++有事务内存扩展的技术规范）  。
	- C++标准提供的保护共享数据的最基本机制是[[mutex]]。
-