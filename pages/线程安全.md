alias:: 线程安全性, thread-safe

- 线程安全性是指在多线程环境中，代码或程序的行为能够正确处理多个线程同时执行，而不引发错误或不可预期的结果。线程安全的代码可以被多个线程安全地并发使用，而不会导致数据污染、竞态条件或任何其他由于线程竞争导致的问题。
- ### 线程安全性的关键要素
	- 1. **原子性（Atomicity）**：
		- 操作要么完全执行，要么完全不执行，不会出现中间状态。
		- 使用原子操作（如`std::atomic`类型或同步原语）确保单个操作的原子性。
	- 2. **互斥性（Mutual Exclusion）**：
		- 同一时间只有一个线程可以访问共享资源或执行特定的代码段。
		- 通常通过互斥锁（如`std::mutex`）实现，确保对共享资源的访问是串行化的。
	- 3. **顺序性（Ordering）**：
		- 操作的执行顺序对结果影响很大，尤其是在读写共享数据时。
		- 通过内存栅栏或其他同步机制来保证操作的顺序性，确保一致的执行顺序。
- ### 线程安全性的问题
	- 1. **竞态条件（Race Conditions）**：
		- 当两个或多个线程并发访问同一资源，并且至少有一个线程在写入时，如果没有适当的同步，就会出现竞态条件。
		- 竞态条件可能导致非确定性的行为和不可预测的结果。
	- 2. **死锁（Deadlock）**：
		- 多个线程相互等待对方释放资源，导致无法继续执行的状态。
		- 死锁通常发生在有多个锁存在，并且线程以不同的顺序请求这些锁时。
	- 3. **活锁（Livelock）**：
		- 线程不停地响应对方的动作，而没有进行实质性的工作，虽然线程处于运行状态，但没有进展。
- ### 实现线程安全的方法
	- **避免共享状态**：尽可能使线程不共享数据或资源，或者使用不可变对象，这样可以自然地避免同步问题。
	- **同步访问共享资源**：使用互斥锁、读写锁（`std::shared_mutex`）、信号量等同步原语来保护共享资源的访问。
	- **使用线程安全的库和数据结构**：许多现代语言和库提供了线程安全的数据结构和API，优先使用这些构建块可以减少直接处理线程同步的负担。
	- **设计考虑并发**：在软件设计阶段考虑线程安全和并发问题，通过设计来减少需要同步的地方。
-