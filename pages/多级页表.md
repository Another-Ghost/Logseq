- #+BEGIN_TIP
  到目前为止，我们一直假设系统只用一个单独的页表来进行地址翻译。但是如果我们有 一 个 32 位的地址空间、 4KB 的页面和 一 个 4 字节的 PTE, 那么即使应用所引用的只是虚拟地址空间中很小的一部分，也总是需要一个 4MB 的页表驻留在内存中。对于地址空间为 64 位的系统来说，问题将变得更复杂。
  #+END_TIP
- 用来[[压缩页表]]的常用方法是使用 *有层次结构的[[页表]]* 。 
  用一个具体的示例是最容易理解这个思想的。假设 32 位虚拟地址空间被分为 4KB 的页，而每个页表条目都是 4 字节。还假设在这一时刻，虚拟地址空间有如下形式：内存的前 2K 个页面分配给了代码和数据，接下来的 6K 个页面还未分配，再接下来的 1023 个页面也未分配，接下来的 1 个页面分配给了用户栈。图 9 - 17 展示了我们如何为这个虚拟地址空间构造一个两级的页表层次结构。一级页表中的每个 PTE 负责映射虚拟地址空间中 一 个 4MB 的片 (chunk), 这里每一片都是由 1024 个连续的页面组成的。比如， PTE 0 映射第一片， PTE 1 映射接下来的 一片，以此类推。假设地址空间是 4GB, 1024 个 PTE 已经足够覆盖整个空间了。如果片 1 中的每个页面都未被分配，那么 一 级 PTEi 就为空 。 例如，图 9 - 17 中，片 2~7是未被分配的。然而，如果在片 t 中至少有一个页是分配了的，那么一级 PTE i 就指向 一个二级页表的基址。例如，在图 9-17 中，片 0 、 1 和 8 的所有或者部分已被分配，所以它们的一级 PTE 就指向二级页表。
	- ![image.png](../assets/image_1701663783491_0.png)