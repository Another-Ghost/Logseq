- 对 C 程序员来说，管理和使用虚拟内存可能是个困难的、容易出错的任务。与内存有关的错误属于那些最令人惊恐的错误，因为它们在时间和空间上，经常在距错误源一段距离之后才表现出来。
	- 将错误的数据写到错误的位置，你的程序可能在最终失败之前运行了好几个小时，且使程序中止的位置距离错误的位置已经很远了。
- ## 间接引用坏指针
	- 在进程的虚拟地址空间中有较大的洞，没有映射到任何有意义的数据。如果我们试图间接引用一个指向这些洞的指针，那么操作系统就会以段异常中止程序。
	- 而且，虚拟内存的某些区域是只读的。试图写这些区域将会以保护异常中止这个程序。
	- 把内容解释为一个地址，并试图将一个字写到这个位置，在最好的情况下，程序立即以异常终止。在最糟糕的情况下， 内容对应于虚拟内存的某个合法的读／写区域，千是我们就覆盖了这块内存，这通常会在相当长的一段时间以后造成灾难性的、令人困惑的后果。
- ## 读未初始化的内存
	- 虽然 bss 内存位置（诸如未初始化的全局 C 变量）总是被加载器初始化为零，但是对于[[堆]]内存却并不是这样的。一个常见的错误就是假设堆内存被初始化为零。
	- 可以使用[[calloc]]替代[[malloc]]来避免这种错误。
- ## 允许栈缓冲区溢出
	- 如果一个程序不检查输入串的大小就写入栈中的目标缓冲区，那么这个程序就会有[[缓冲区溢出]]错误 (buffer overflow bug) 。
- ## [[错位错误]]
- ## 引用不存在的变量
	- ``` c
	  int * stackref ()
	  {
	  	intval;
	  	return &val;
	  }
	  ```
	- 这个函数返回一个指针（比如说是 `p` ), 指向栈里的一个局部变量，然后弹出它的栈帧。尽管 `p` 仍然指向一个合法的内存地址，但是它已经不再指向一个合法的变量了。当以后在程序中调用其他函数时，内存将重用它们的栈帧。再后来，如果程序分配某个值给 `*p` , 那么它可能实际上正在修改另一个函数的栈帧中的一个条目，从而潜在地带来灾难性的、令人困惑的后果。
- ## [[内存泄露]]
-