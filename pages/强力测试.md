alias:: 压力测试

- 强力测试背后的思想是，让代码承受压力运行，看它是否崩溃。这往往需要多次运行代码，还可能在同一项测试中发起许多线程。若代码**按某种特定的调度编排运行**才发生错误，那么代码运行的次数越多，错误就越有可能复现。如果只测试一次并通过，我们就能稍微放心 ，认为代码可以工作。如果一口气测试 10 次，且它每次都能通过，我 们[[置信]]的程度将大大提高。如果测试10亿次依然全数通过，我们则高度置信代码正确无误。
- 我们置信的程度其实取决于每项测试的目标代码的**代码量**。如果测试的粒度颇为精细，那么强力测试会让我们对代码产生高度置信。 反之，如果测试的目标代码的代码量过大，那么，多线程调度次序的编排组合数目会爆增，即便成功通过了10亿次测试，代码完全正确的置信度也仍然很低。
- 强力测试的缺点是可能导致[[错误置信]]。假设我们编写的测试代码无法再现出错场景，即便稍微改动测试环境，也可令受测的目标代码每次都出错，那么，无论按原来的测试方式运行多少次，也不可能呈现错误。最无奈的情形是，导致错误的运行环境只存在于特定系统中 ，但我们运行测试样例的系统却与之不同，无法复现错误。除非我们的代码只在一种系统上运行，并且它与测试系统完全一致，方可保证错误复现。而某些测试环境由特定的硬件和操作系统组成，有可能令错误无法复现。
	- 上述情形的经典实例是，在单处理器系统上测试多线程应用。许多错误只会在真正的多处理器系统中出现，如条件变量和缓存乒乓。而在测试环境中，每个线程都被迫由同一个处理器负责运行，故它们实际上自动按串行方式执行。
	- 单核/多核并不是唯一的变数，在不同的处理器架构中，其同步功能和内存次序机制也互不相同。例如，在x86和 x86-64 架构上，原子化载入操作的行为和效果肯定相同，无论该操作是以 `memory_order _relaxed` 标记还是以 `memory_order_seqcst` 标记。然而，即使在基于 x86 架构的系统中，采用宽松内存次序的代码工作正常，但因为其他系统具备粒度更精细的^^内存次序指令集^^（如[[SPARC]]），仍有可能导致同一份代码出错。
- 如果我们要将应用软件移植到多个目标平台上，那就有必要从各种类型中选出**有代表意义的系统**进行专门测试。
- 为了让强力测试成功，避免潜在的错误置信至关重要。这要求我们谨慎思考，确定 测试方案，既要选定目标代码的测试单元，又要仔细设计驱动测试的代码和测试环境。 我们需要令测试尽量涵盖可能的代码执行路径，并尽可能多地进行线程间交互。不仅如 此，我们还需要清楚已经测试过哪些功能，而哪些功能还没测试。