- 在更改[[内存排序]]之前，需要检查操作并确定它们之间所需的关系。然后你可以回过头来找到提供这些关系的最小内存排序。为此，你必须从不同场景中线程的角度来看待这个问题。
- 最简单的可能场景是一个线程将数据项推入栈，稍后另一个线程将其从栈中弹出，所以我们从这里开始。在这种简单情况下，涉及三个重要的数据（来自[[引用计数无锁栈]]）。第一个是用于传输数据的 `counted_node_ptr`：`head`。第二个是 `head` 指向的节点结构，第三个是该节点指向的数据项。
- 执行 `push()`  的线程首先构建数据项和节点，然后设置 `head`。**执行 `pop()` 的线程首先加载 `head` 的值**，然后在 `head` 上执行 `compare/exchange` 循环以增加引用计数，然后读取节点结构以获取 `next` 的值。这里你可以看到所需的关系；`next` 是一个普通的非原子对象，因此为了安全地读取它，必须在存储（由推送线程）和加载（由弹出线程）之间建立一个先发生（[[happens-before]]）关系。因为 `push()` 中唯一的原子操作是 `compare_exchange_weak()`，而且需要一个释放操作才能在线程之间建立一个先发生关系，因此 `compare_exchange_weak()` 必须是 [[std::memory_order_release]] 或更强。如果 `compare_exchange_weak()` 调用失败，什么都没变，你继续循环，所以在这种情况下只需要 `std::memory_order_relaxed`：
  ```cpp
  void push(T const& data) {
    counted_node_ptr new_node;
    new_node.ptr = new node(data);
    new_node.external_count = 1;
    new_node.ptr->next = head.load(std::memory_order_relaxed);
    while(!head.compare_exchange_weak(new_node.ptr->next, new_node,
        std::memory_order_release, std::memory_order_relaxed));
  }
  ```
- 那么 `pop()` 的代码为了获得你需要的先发生关系，在访问 `next` 之前必须有一个 `std::memory_order_acquire` 或更强的操作。你解引用以访问 `next` 字段的指针是 `increase_head_count()` 中 `compare_exchange_strong()` 读取的旧值，因此在成功时需要`std::memory_order_acquire`排序。就像在 `push()` 中的调用一样，如果交换失败，你只需再次循环，所以在失败时可以使用宽松的排序：
  ```cpp
  void increase_head_count(counted_node_ptr& old_counter) {
    counted_node_ptr new_counter;
    do {
        new_counter = old_counter;
        ++new_counter.external_count;
    } while (!head.compare_exchange_strong(old_counter, new_counter,
        std::memory_order_acquire, std::memory_order_relaxed));
    old_counter.external_count = new_counter.external_count;
  }
  ```
  如果 `compare_exchange_strong()` 调用成功，你知道读取的值的 `ptr` 字段设置为现在存储在 `old_counter` 中的内容。因为 `push()` 中的存储是一个释放操作，而这个 `compare_exchange_strong()` 是一个获取操作，所以存储与加载同步，并且你有一个先发生关系。因此，`push()` 中对 `ptr` 字段的存储在 `pop()` 中 `ptr->next` 的访问之前发生，这样你就安全了。
  请注意，初始 `head.load()` 的内存排序对这个分析没有影响，因此你可以安全地为其使用 `std::memory_order_relaxed`。
- 接下来，让我们考虑将 `head` 设置为 `old_head.ptr->next` 的 `compare_exchange_strong()`。为了保证此线程的数据完整性，你是否需要这个内存排序操作提供额外的保障？
  如果交换成功，你会访问 `ptr->data`，因此需要确保 `push()` 线程中的 `ptr->data` 的存储在读取之前发生。但你**已经拥有这个保证**：`increase_head_count()` 中的获取操作确保了`push()`线程中的存储与 `compare-exchange` 之间有一个同步关系。因为`push()`线程中的存储到数据在 `head` 之前发生，而 `increase_head_count()` 的调用在 `ptr->data` 的读取之前发生，因此存在一个先发生关系，即使 `pop()` 中的这个 `compare-exchange` 使用 `std::memory_order_relaxed`，也不会有问题。
  唯一其他可以更改 `ptr->data` 的地方是 `swap()` 调用，**没有其他线程可以对同一个节点进行操作；这是 `compare-exchange` 的全部目的**。
- 如果 `compare_exchange_strong()` 失败，`old_head` 的新值直到下次循环时才会被触碰，你已经决定 `increase_head_count()` 中的 `std::memory_order_acquire` 足够了，因此 `std::memory_order_relaxed` 也足够。
- 其他线程呢？为了确保其他线程仍然安全，你是否需要更强的保证？
  答案是否定的，**因为 `head` 只会被[[compare-exchange]]操作修改。因为这些是[[读-修改-写操作]]，它们构成了由 `push()` 中的 `compare/exchange` 领导的[[释放序列]]。
  因此，`push()` 中的 `compare_exchange_weak()` 与 `increase_head_count()` 中的 `compare_exchange_strong()` 同步（两个线程间的这些操作是同步的），即使在此期间许多其他线程修改了 `head`。**
- ### 引用计数的同步
- 你差不多完成了：唯一剩下的操作是用于修改 引用计数 的 `fetch_add()` 操作。从这个节点返回数据的线程在知道没有其他线程可以修改节点数据情况下，可以继续进行。
  但是，任何未成功获取数据的线程都知道另一个线程确实修改了节点数据；成功的线程使用 `swap()` 提取了引用的数据项。因此，你需要确保 `swap()` 在删除之前发生，以避免数据竞争。
  最简单的方法是让成功返回分支中的 `fetch_add()` 使用 `std::memory_order_release`，而在循环重试分支中的 `fetch_add()` 使用 `std::memory_order_acquire`。但这仍然过度了：只有一个线程会进行删除（设置计数为零的那个），所以只有该线程需要进行获取操作。庆幸的是，因为 `fetch_add()` 是一个读-修改-写操作，它构成了[[释放序列]]的一部分，所以你可以通过额外的加载来做到这一点。如果循环重试分支将引用计数减少到零，它可以使用 `std::memory_order_acquire` 重新加载引用计数以确保所需的同步关系，而 `fetch_add()` 本身可以使用 `std::memory_order_relaxed`。使用新的 `pop()` 版本的最终栈实现如下所示。
- ```cpp
  template<typename T>
  class lock_free_stack
  {
  private:
      struct node;
      struct counted_node_ptr
      {
          int external_count;
          node* ptr;
      };
      struct node
      {
          std::shared_ptr<T> data;
          std::atomic<int> internal_count;
          counted_node_ptr next;
          node(T const& data_):
              data(std::make_shared<T>(data_)),
              internal_count(0)
          {}
      };
      std::atomic<counted_node_ptr> head;
      void increase_head_count(counted_node_ptr& old_counter)
      {
          counted_node_ptr new_counter;
          do
          {
              new_counter=old_counter;
              ++new_counter.external_count;
          }
          while(!head.compare_exchange_strong(old_counter,new_counter,
              std::memory_order_acquire,
              std::memory_order_relaxed)); //memory_order_acquire 保证获取到的head是node和external_count都准备好的head
          old_counter.external_count=new_counter.external_count;
      }
  public:
      ~lock_free_stack()
      {
          while(pop());
      }
      void push(T const& data)
      {
          counted_node_ptr new_node;
          new_node.ptr=new node(data);
          new_node.external_count=1;
          new_node.ptr->next=head.load(std::memory_order_relaxed);
          while(!head.compare_exchange_weak(new_node.ptr->next,new_node,
              std::memory_order_release,
              std::memory_order_relaxed));    // memory_order_release 保证head的更新不会在new_node完全完成前执行
      }
      std::shared_ptr<T> pop()
      {
          counted_node_ptr old_head=
              head.load(std::memory_order_relaxed);
          for(;;)
          {
              increase_head_count(old_head);
              node* const ptr=old_head.ptr;
              if(!ptr)
              {
                  return std::shared_ptr<T>();
              }
              //可以为 memory_order_relaxed 是因为 increase_head_count 已经保证了head的完整性。
              //只要保证完整性，哪一个线程先pop()、push()，哪一个后pop()、push()，都无所谓。
              //并且release操作后的读改写操作共同链成一释放序列为释放队列中的原子读改写操作无论采用何种内存模型，都会保证原子性，所以每次读最新的值，写操作也能被其他线程读取到。
              if(head.compare_exchange_strong(old_head,ptr->next,
                  std::memory_order_relaxed)) 
              {                               
                  std::shared_ptr<T> res;
                  res.swap(ptr->data);
                  int const count_increase=old_head.external_count-2;
                  if(ptr->internal_count.fetch_add(count_increase,
                      std::memory_order_release)==-count_increase)    //memory_order_release 是为了保证返回数据 ptr->data 的获取发生在其释放之前 
                  {
                      delete ptr;
                  }
                  result.emplace_back(*res);
                  return res;
              }
              else if(ptr->internal_count.fetch_add(-1,
                  std::memory_order_relaxed)==1)
              {
                  ptr->internal_count.load(std::memory_order_acquire);
                  delete ptr;
              }
          }
      }
      std::vector<T> result;
  };
  ```
- 这确实相当费力，但你最终做到了，栈因此变得更好。通过在仔细考虑的方式中使用更宽松的操作，性能得到了提升，而不会影响正确性。
  > 正如你所见，`pop()` 的实现现在是 37 行，而锁定栈节中的等效 `pop()` 只有 8 行，而没有内存管理的无锁栈节中只有 7 行。随着我们继续研究编写无锁队列，你会看到类似的模式：无锁代码中的很多复杂性来自于管理内存。
- ## 测试
-