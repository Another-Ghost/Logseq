- 一旦你走出了顺序一致性的美好世界，事情开始变得复杂。最大的一个问题可能是，事件不再有一个单一的全局顺序。这意味着不同的线程可以看到同一操作的不同视图，任何你对不同线程的操作整齐地一个接一个交错执行的心理模型都必须抛弃。你不仅要考虑事情真正并发发生的情况，而且线程不必就事件的顺序达成一致。
- 为了编写（或甚至理解）使用非默认`memory_order_seq_cst`内存排序的任何代码，**彻底理解**这一点绝对至关重要。这不仅仅是编译器可以重新排序指令。即使线程正在运行相同的代码片段，它们也可以因为其他线程中的操作在没有明确排序约束的情况下，对事件的顺序持有不同的看法，因为**不同的CPU[[缓存]]和[[内部缓冲区]]可以为相同的内存持有不同的值**。这一点非常重要：线程不必就事件的顺序达成一致。
  id:: 65e05114-c3a8-449f-809e-0d5209146a19
- 你不仅要抛弃基于操作交错的心理模型，还要抛弃基于编译器或处理器[[重新排序指令]]的想法的心理模型。
  **在没有其他[[排序约束]]的情况下，默认唯一的约束是所有线程都同意每个单独变量的修改顺序。**在不同线程上，对不同变量的操作可以以不同的顺序出现，只要看到的值与施加的 任何额外排序约束 一致即可。
- 最好通过完全走出顺序一致性世界，并对所有操作使用`memory_order_relaxed`来演示这一点。一旦你掌握了这一点，你就可以回到获取-释放排序，这允许你有选择地引入操作之间的排序关系，并重新获得一些理智。