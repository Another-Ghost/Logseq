- #+BEGIN_TIP
  为什么需要消息队列？
  相比本章介绍的其他通信机制，消息队列是唯一以消息为（内核提供的）数据抽象的通信方式。应用可以通过消息队列来发送消息以及接收消息。发送和接收的接口是内核提供的。此外，消息队列是一种非常灵活的通信机制，支持多个发送者和接收者同时存在。Linux还为消息队列中的每个消息提供了类型的抽象，使得消息的发送者和接收者可以根据类型来选择性地处理消息。
  本节将介绍[[System V 消息队列]]。
  #+END_TIP
- 消息队列在内核中的表示是[[队列]]数据结构。
  id:: 65f08b74-287c-492c-9fae-4066e43123dd
- 当创建新的消息队列时，内核将从系统内存中分配一个队列数据结构，作为消息队列的[[内核对象]]。
- 可以看到，这个对象有其对应的权限，以及消息头部指针。队列的消息由这个头部指针引出，每个消息都有指向下一个消息的指针（或者为空）(链表）。在消息的结构体中，除了“下一个”指针之外，就是消息的内容。
- [[消息]]的内容包含两部分：数据和类型。
	- 数据是一段内存数据，和管道中的字节流相似。
	- 类型是用户态程序为每个消息指定的。
	  在设计中，内核不需要知道类型的语义，仅仅保存并基于类型进行简单的查找。
	  类型的具体意义需要用户态程序自己来管理。
- ## 基本操作
	- 消息队列的操作一般被抽象为四个基本操作：[[`msgget`]]，[[`msgsnd`]]，[[`msgrcv`]]，[[`msgctl`]]。这四个操作在 Linux 系统上被实现为^^系统调用^^。
	- [[`msgget`]]允许进程获取已有消息队列的连接，或者创建一个新的消息队列。
	- 消息队列本质上采用的是[[信箱]]的通信方式。发送者和接收者在通信过程中，只需要建立好对同一个信箱（此处的“队列”）的访问，就相当于建立了[[通信连接]]。
	  只要有对应的权限，消息队列允许任意数量的进程连接到同一通信连接上（即同一队列上）。
	- [[`msgctl`]]可以控制和管理消息队列，如修改消息队列的权限信息或删除该消息队列。
	- 进程可以通过[[`msgsnd`]]向消息队列发送消息，通过[[`msgrcv`]]从消息队列接收消息。
		- 多个进程可以同时向队列发送消息或从队列接收消息。
		- 消息的发送和接收成功的标志，是消息被放到队列上或者从队列上取出。大部分情况下这两个过程是非阻塞的：对发送者来说，只要队列有空闲的空间就可以向队列发送消息，而接收者只要有未读消息就可以直接读取消息并完成操作。
		- 若发送消息时消息队列没有可用空间或接收消息时没有未读消息，默认的操作是^^阻塞进程^^，直到有空间腾出或者新的消息到来。
		- Linux 内核在发送和接收消息的接口（`msgsend`和`msgrcv`）上允许用户指定是否等待（`NOWAIT`选项）。若用户指定了`NOWAIT`，内核可以直接返回相关的错误信息，用户进程不会阻塞。
-