alias:: 虚拟内存

- 虚拟内存是[[硬件异常]]、[[硬件地址翻译]]、[[主存]]、[[磁盘文件]]和[[内核软件]]的完美交互，它为每个[[进程]]提供了一个**大的、一致的和私有的**[[地址空间]]。
  通过一个很清晰的机制，虚拟内存提供了三个重要的能力：
	- 它将[[主存]]看成是一个存储在[[磁盘]]上的[[地址空间]]的[[高速缓存]]，在主存中只保存活动区域，并根据需要在磁盘和主存之间来回传送数据，通过这种方式，它高效地使用了主存。
	  logseq.order-list-type:: number
	- 它为每个进程提供了一致的地址空间，从而简化了内存管理。
	  logseq.order-list-type:: number
	- 它保护了每个进程的地址空间**不被其他进程破坏**。
	  logseq.order-list-type:: number
	- collapsed:: true
	  #+BEGIN_TIP
	  之所以要理解虚拟内存，是因为虚拟内存是：
	  #+END_TIP
		- 核心的。虚拟内存遍及计算机系统的所有层面，在硬件异常、汇编器、链接器、加载器、共享对象、文件和进程的设计中扮演着重要角色。
		  logseq.order-list-type:: number
		- 强大的。虚拟内存遍及计算机系统的所有层面，在硬件异常、汇编器、链接器、加载器、共享对象、文件和进程的设计中扮演着重要角色。
		  logseq.order-list-type:: number
		- 危险的。如果虚拟内存使用不当，应用将遇到复杂危险的与内存有关的错误。例如，一个带有错误指针的程序可以 立即崩溃千＂段错误”或者“保护错误。
		  logseq.order-list-type:: number
- # [[地址空间]]
- # 作为缓存工具的VM
	- ## 虚拟页
	  概念上而言，虚拟内存 被组织为一个由存放在[[磁盘]]上的 N个连续的字节大小的单元 组成的[[数组]] 。 每[[字节]]都有一个唯一的[[虚拟地址]]，作为到 数组 的索引。
	  [[磁盘]]上数组的内容被缓存在[[主存]]中 。 和存储器层次结构中其他缓存一样，磁盘（较低层）上的数据被分割成[[块]]，这些块作为[[磁盘]]和[[主存]]（较高层）之间的 传输单元 。VM系统 通过将 虚拟内存 分割为称为[[虚拟页]](VP) 的大小固定的 块 来处理这个问题 。 每个虚拟页的大小为 $P=2^p$ 字节 。
	- ## 物理页
	  类似地，[[物理内存]]被分割为[[物理页]](PP) , 大小也为 $P$ 字节。
	- 在任意时刻，[[虚拟页面]]的集合都分为三个不相交的子集：
		- [[未分配页]]： VM 系统还未分配（或者创建）的页 。 未分配的块没有任何数据和它们相关联，因此也就**不占用任何[[磁盘]]空间**。
		  logseq.order-list-type:: number
		- [[缓存页]]：当前已缓存在物理[[内存]]中的已分配页 。
		  logseq.order-list-type:: number
		- [[未缓存页]]：未缓存在物理[[内存]]中的已分配页 。
		  logseq.order-list-type:: number
		- logseq.order-list-type:: number
		  #+BEGIN_PINNED
		  下图的示例展示了一个有 8 个虚拟页的小虚拟内存。
		  ![image.png](../assets/image_1701353480678_0.png)
		  #+END_PINNED
	- ## [[DRAM]]
		- 因为大的[[不命中处罚]]和 访问第一个字节的开销 ，[[虚拟页]]往往很大，通常是 4KB~2MB 。由于大的不命中处罚， DRAM缓存是[[全相联]]的，即任何[[虚拟页]]都可以放置在任何的[[物理页]]中。
		  不命中时的[[替换策略]]也很重要，因为替换错了虚拟页的处罚也非常之高。因此，与硬件对[[SRAM]]缓存相比，[[操作系统]]对[[DRAM]]缓存使用了更复杂精密的 替换算法 。
		  最后，因为对磁盘的访问时间很长， DRAM 缓存总是使用[[写回]]，而不是[[直写]]。
	- ## [[页表]]
	- ## [[页命中]]