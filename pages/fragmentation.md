alias:: 碎片

- 造成[[堆]]利用率很低的主要原因是一种称为[[碎片]]的现象，当虽然有未使用的内存但不能用来满足分配请求时，就发生这种现象。
- 有两种形式的碎片：
	- [[内部碎片]]是在一个[[已分配块]]比[[有效载荷]]大时发生的。
	  logseq.order-list-type:: number
		- 很多原因都可能造成这个问题。
			- 例如，一个分配器的实现可能对已分配块强加一个最小的大小值，而这个大小要比某个请求的有效载荷大。
			- 或者，分配器可能增加块大小以满足[[对齐约束条件]]。
		- 内部碎片的量化是简单明了的。它就是已分配块大小和它们的有效载荷大小之差的和。因此，在任意时刻，内部碎片的数最只取决于以前请求的模式和分配器的实现方式。
	- [[外部碎片]]是当[[空闲块]]合计起来足够满足一个分配请求，但是没有一个单独的空闲块足够大可以来处理这个请求时发生的。如果不向内核请求额外的虚拟内存就无法满足这个请求。
	  logseq.order-list-type:: number
- [[外部碎片]]比[[内部碎片]]的量化要困难得多，因为它不仅取决于 *以前请求的模式* 和 *分配器的实现方式* ，还取决于 *将来请求的模式* 。
	- 例如，假设在 $k$ 个请求之后，所有空闲块的大小都恰好是 4 个字。
	  如果将来所有的分配请求都要求小于或者等于4个字的块，那么就不会有外部碎片。另一方面，如果有一个或者多个请求要求比4个字大的块，那么这个堆就会有外部碎片。
- 因为外部碎片难以量化且不可能预测，所以分配器通常采用[[启发式策略]]来试图维持少量的大空闲块，而不是维持大量的小空闲块。
	- logseq.order-list-type:: number