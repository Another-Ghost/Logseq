alias:: 无锁数据结构, 无锁并发数据结构, lock-free concurrent data structure

- 为了使数据结构符合[[无锁]]（Lock-Free）的要求，必须允许多个线程同时访问该数据结构。
  它们不必能够执行相同的操作；一个无锁队列可能允许一个线程进行推送操作和另一个线程进行弹出操作，但如果两个线程尝试同时推送新项目，则可能会出现问题。
  不仅如此，如果其中一个访问数据结构的线程在操作过程中被调度程序**暂停**，其他线程必须仍能完成它们的操作，无需等待被暂停的线程。
- 使用[[比较交换操作]]的算法通常会包含循环。使用 比较交换操作 的原因是其他线程可能同时修改了数据，在这种情况下，代码需要重做部分操作后再次尝试比较/交换。
	- 如果其他线程被**暂停**，这段代码最终成功执行比较/交换操作，那么它仍然可以被认为是无锁的。
	- 如果没有成功，你会得到一个自旋锁，这是[[非阻塞]]的，但不是无锁的。
- 这些包含循环的无锁算法可能导致某个线程遭受[[饥饿]]现象。如果另一个线程以“错误”的时间点执行操作，其他线程可能取得进展，但第一个线程不得不不断重试其操作。避免此问题的数据结构既是{{无锁}}的也是[[无等待]]的。
- ## [[无等待数据结构]]
- ## 无锁数据结构的优缺点
  鉴于编写无锁或无等待数据结构正确性的难度，你需要一些非常好的理由来编写它们；你需要确保好处超过了成本。因此，让我们来考察^^影响平衡的几个要点^^。
	- ### 最大化并发
	  logseq.order-list-type:: number
	  归根结底，使用无锁数据结构的主要原因是为了实现**最大的并发性**。
		- 在基于锁的容器中，总有一个线程可能需要阻塞并等待另一个线程完成其操作才能继续进行；通过互斥来阻止并发正是互斥锁的全部目的。使用无锁数据结构时，每个步骤都会有一些线程取得进展：
		  collapsed:: true
			- 每个线程都可以**前进**，不管其他线程在做什么；
			- 不需要等待。这是一个理想的属性，但很难实现。很容易最终编写出本质上是自旋锁的代码。
	- ### 鲁棒性
	  logseq.order-list-type:: number
	  使用无锁数据结构的第二个原因是**鲁棒性**。
		- 如果一个线程在持有锁的同时死亡，那么该数据结构将永久损坏。但是如果一个线程在对无锁数据结构操作过程中死亡，除了该线程的数据外，没有任何东西会丢失；其他线程可以正常进行。
		- 这里的另一面是，如果你不能阻止线程访问数据结构，那么你必须小心确保[[不变性]]得到维持，或选择可以维持的替代不变性。
		- 此外，你还必须注意对操作施加的排序约束。为了避免与数据竞争相关的未定义行为，你必须对修改使用[[原子操作]]。但仅此还不够；你必须确保**变更 对其他线程 以正确的顺序可见**。
	- ### 死锁与活锁
	  logseq.order-list-type:: number
	  由于没有任何锁，无锁数据结构**不可能发生[[死锁]]**，尽管有可能发生[[活锁]]。
		- 活锁发生在两个线程都试图改变数据结构，但对于每个线程来说，由于另一个线程所做的更改要求重启操作，因此两个线程都会循环并再次尝试。
		- #### 例子
		  想象两个人试图通过一个狭窄的间隙。如果他们同时前进，他们会卡住，所以他们不得不退出并再次尝试。除非有人先到达（通过协议、更快或纯粹的运气），否则循环将重复。
		- 正如这个简单的例子所示，活锁通常是短暂的，因为它们依赖于线程的确切调度。
		- 因此，它们会耗费性能而不是造成长期问题，但仍然是需要警惕的。
		- 根据定义，[[无等待]]代码不能有[[活锁]]，因为执行操作总是有一个步骤上限。
		  collapsed:: true
			- 这里的另一面是，算法可能比替代方案更复杂，并且即使没有其他线程访问数据结构时也可能需要更多步骤。
	- ### 总体性能
	  logseq.order-list-type:: number
	  这引出了无锁和无等待代码的另一个缺点：尽管它可以增加对数据结构操作的并发潜力并减少单个线程的等待时间，但可能会**降低总体性能**。
		- 首先，用于无锁代码的原子操作可能比非原子操作慢得多，并且在无锁数据结构中可能有更多此类操作，而不是在基于锁的数据结构的互斥锁锁定代码中。
		- 不仅如此，硬件还必须在访问相同原子变量的线程之间同步数据。
		  多个线程访问相同原子变量所引发的[[缓存乒乓现象]]可能是显著的性能损耗。
		- 如同其他情况一样，检查相关的性能方面（无论是最坏情况下的等待时间、平均等待时间、整体执行时间还是其他什么）非常重要，无论是使用基于锁的数据结构还是无锁数据结构，都要在提交之前进行比较。
	- ### 实现复杂度
	  logseq.order-list-type:: number
	  所有这些意味着，不使用锁编写线程安全的数据结构要比使用锁编写难得多。
- ## 无锁数据结构示例
- 为了演示设计无锁数据结构时使用的一些技术，我们将查看一系列简单数据结构的无锁实现。
- 正如已经提到的，无锁数据结构依赖于使用**原子操作**及其相关的**内存排序**保证，以确保**数据按正确的顺序对其他线程可见**。
	- >最初，我们将使用默认的 `memory_order_seq_cst` 内存排序对所有原子操作进行排序，因为这是最容易推理的（记住所有 `memory_order_seq_cst` 操作形成一个总序）。但在后面的示例中，我们将考虑将一些排序约束减少到 `memory_order_acquire`、`memory_order_release`，甚至是 `memory_order_relaxed`。
	  虽然这些示例中没有直接使用互斥锁，但值得记住的是，只有 [[std::atomic_flag]]保证在实现中不使用锁。在某些平台上，看似无锁的代码可能在 C++ 标准库实现中使用了锁。在这些平台上，一个简单的基于锁的数据结构可能更合适，但情况不仅仅如此；在选择实现之前，你必须确定你的需求并评估满足这些需求的各种选项。
- ### [[无锁的线程安全栈]]
  logseq.order-list-type:: number
- ### [[无锁线程安全队列]]
  logseq.order-list-type:: number
- ## [[实现无锁数据结构的原则]]