- 如果并发代码不能保证[[异常安全]]，就会破坏[[不变量]]或导致[[条件竞争]]，应用程序也许会因某操作抛出异常而意外结束。
- ```cpp
  //list 1
  #include <vector>
  #include <thread>
  #include <algorithm>
  template<typename Iterator,typename T>
  struct accumulate_block
  {
      void operator()(Iterator first,Iterator last,T& result)
      {
          result=std::accumulate(first,last,result); // 1
      }
  };
  
  template<typename Iterator,typename T>
  T parallel_accumulate(Iterator first,Iterator last,T init)
  {
      unsigned long const length=std::distance(first,last); // 2 
  
      if(!length)
          return init;
  
      unsigned long const min_per_thread=25;
      unsigned long const max_threads=
          (length+min_per_thread-1)/min_per_thread;
  
      unsigned long const hardware_threads=
          std::thread::hardware_concurrency();
  
      unsigned long const num_threads=
          std::min(hardware_threads!=0?hardware_threads:2,max_threads);
  
      unsigned long const block_size=length/num_threads;
  
      std::vector<T> results(num_threads); // 3
      std::vector<std::thread> threads(num_threads-1); // 4
  
      Iterator block_start=first; // 5
      for(unsigned long i=0;i<(num_threads-1);++i)
      {
          Iterator block_end=block_start; // 6
          std::advance(block_end,block_size);
          threads[i]=std::thread( // 7
              accumulate_block<Iterator,T>(),
              block_start,block_end,std::ref(results[i]));
          block_start=block_end; // 8
      }
      accumulate_block<Iterator,T>()(block_start,last,results[num_threads-1]); // 9
  
      std::for_each(threads.begin(),threads.end(),
                    std::mem_fn(&std::thread::join));
  
      return std::accumulate(results.begin(), results.end(),init); // 10
  }
  
  ```
- 如果我们认真分析新线程应当具备什么功能，很明显，它需要计算出一个值并将其返回，同时还准许相关代码抛出异常。
  按照设计意图，只要 [[std::packaged_task]] 类和 [[std:future]] 类“联手出击”，即可精准实现上述功能。代码清单 2 就是采用 `std::packaged task` 类重写代码清单 1 的代码。
- ```cpp
  //list 2
  #include <algorithm>
  #include <thread>
  #include <vector>
  #include <future>
  template<typename Iterator,typename T>
  struct accumulate_block
  {
      T operator()(Iterator first,Iterator last)	// 1
      {
          return std::accumulate(first,last,T());	// 2
      }
  };
  
  template<typename Iterator,typename T>
  T parallel_accumulate(Iterator first,Iterator last,T init)
  {
      unsigned long const length=std::distance(first,last);
  
      if(!length)
          return init;
  
      unsigned long const min_per_thread=25;
      unsigned long const max_threads=
          (length+min_per_thread-1)/min_per_thread;
  
      unsigned long const hardware_threads=
          std::thread::hardware_concurrency();
  
      unsigned long const num_threads=
          std::min(hardware_threads!=0?hardware_threads:2,max_threads);
  
      unsigned long const block_size=length/num_threads;
  
      std::vector<std::future<T> > futures(num_threads-1);	// 3
      std::vector<std::thread> threads(num_threads-1);
  
      Iterator block_start=first;
    	try
      {
        for(unsigned long i=0;i<(num_threads-1);++i)
        {
            Iterator block_end=block_start;
            std::advance(block_end,block_size);
            std::packaged_task<T(Iterator,Iterator)> task(	// 4
                accumulate_block<Iterator,T>());
            futures[i] = task.get_future();	// 5
            threads[i] = std::thread(std::move(task),block_start,block_end);	// 6
            block_start = block_end;
        }
        T last_result=accumulate_block<Iterator,T>(block_start,last);	// 7
  
      	std::for_each(threads.begin(),threads.end(),
                    std::mem_fn(&std::thread::join));
  	catch(...)
      {
        	for (unsigned long i=0; i< (num_thread-1) ; ++i) 
          {
            	if (threads[i].joinable())
  				thread[i].join();
          }
        	throw;
      }
      T result = init;	// 8
      for(unsigned long i = 0; i < (num_threads - 1); ++i)
      {
          result+=futures[i].get();	// 9
      }
      result += last_result;	// 10
      return result;
  }
  ```
- 由于我们须从 `future` 对象取各数据段的求和结果，因此改用一个简单的 `for` 循环进行总体求和，累加计算以给定的原始值（`parallel_accumulate`（的最后一项参数）为基础⑧，再与各 `future` 对象所含的结果逐一相加⑨。若某任务抛出了异常，则会被对应的 `future` 捕获，在⑨处调用 `get()` 时会再次抛出异常。最后，我们加上末尾数据段的结果，求出总体和，返回给调用者⑩。
- 上面的修改解决了一个潜在的问题：工作线程所抛出的异常会被 `future` 捕获，转而在主线程上重新抛出。假设抛出异常的工作线程不止一个，那就只有一个异常能够向上传递，但问题不大。如果这确实构成问题，我们可以采用 [[std::nested_exception]] 之类的工具捕获全部异常，在主线程上改为抛出这种类型的异常（`std:nested _exception`）。
- 剩下的问题是：从第一个线程的创建开始，直到全部汇合完成，在此期间若有异常抛出，还可能导致[[线程泄漏]]（leaking thread，见后文 `std::async()` 异常安全处）。对于该问题，最简单的解决方法是先捕获任何异常，若一个 `std::thread` 对象上的 `joinable()` 结果依然 `true`，则让主线程汇合对应的线程，之后再重新抛出异常。
- 这样，代码便能正确工作了。所有线程最终都会汇合，不论控制流程以什么方式离开代码块。
- id:: 6633e66d-7ab5-487a-ba27-b846875700df
  ```cpp
  //list 3
  #include <iterator>
  #include <vector>
  #include <thread>
  #include <future>
  #include <numeric>
  
  struct join_threads
  {
  	std::vector<std::thread>& threads;
  public:
    	explicit join_threads(std::vector<std::thread>& threads_):
      threads(threads_)
    	{}
    	~join_threads()
    	{
      	for(unsigned long i=0;i<threads.size();++i)
      	{
        		if(threads[i].joinable())
          		threads[i].join();
  		} 
      }
  };
      
  template<typename Iterator,typename T>
  struct accumulate_block
  {
      T operator()(Iterator first,Iterator last)
      {
          return std::accumulate(first,last,T());
      }
  };
  template<typename Iterator,typename T>
  T parallel_accumulate(Iterator first,Iterator last,T init)
  {
      unsigned long const length=std::distance(first,last);
  
      if(!length)
          return init;
  
      unsigned long const min_per_thread=25;
      unsigned long const max_threads=
          (length+min_per_thread-1)/min_per_thread;
  
      unsigned long const hardware_threads=
          std::thread::hardware_concurrency();
  
      unsigned long const num_threads=
          std::min(hardware_threads!=0?hardware_threads:2,max_threads);
  
      unsigned long const block_size=length/num_threads;
  
      std::vector<std::future<T> > futures(num_threads-1);
      std::vector<std::thread> threads(num_threads-1);
      join_threads joiner(threads); // 1
  
      Iterator block_start=first;
      for(unsigned long i=0;i<(num_threads-1);++i)
      {
          Iterator block_end=block_start;
          std::advance(block_end,block_size);
          std::packaged_task<T(Iterator,Iterator)> task(
              accumulate_block<Iterator,T>());
          futures[i]=task.get_future();
          threads[i]=std::thread(std::move(task),block_start,block_end);
          block_start=block_end;
      }
      T last_result=accumulate_block<Iterator,T>(block_start,last);
      T result=init;
      for(unsigned long i=0;i<(num_threads-1);++i)
      {
          result+=futures[i].get(); // 2
      }
      result += last_result;
      return result;
  }
  
  ```
  这里，我们先创建线程容器，再依据它创建一个新设计的 `join_threads` 类的实例①，以在函数退出时自动汇合全部线程。原本显式编写的汇合线程的循环便可删除（见前文`try/catch`块的代码片段），因此我们就能确信全部线程都会汇合，不管函数以什么方式退出。请注意，在结果准备就绪之前，`futures[i].get()` 的调用会一直阻塞②，故无须在该处汇合线程。
- ## 通过[[std::async]]实现线程安全
	- 前文已经介绍过，`std::async()` 会让线程库替我们管控线程，任何生成的线程一旦运行完成，对应的 `future` 即进入就绪状态。
	  针对 `std::async()` 的线程安全，我们需要注意的关键之处是，如果不等 [[future]] 进入就绪状态就将其销毁，`future` 对象的析构函数依然会等待其线程运行结束再执行；否则，线程仍会运行，万一还持有指向局部数据的引用，便会导致线程资源遗失。而此弊病凭借上述等待行为得以根除。代码清单 4 展示了采用 `std:async()` 的算法实现，代码满足异常安全。
	- ```cpp
	  //list 4
	  #include <future>
	  #include <algorithm>
	  template<typename Iterator,typename T>
	  T parallel_accumulate(Iterator first,Iterator last,T init)
	  {
	      unsigned long const length=std::distance(first,last);	// 1
	      unsigned long const max_chunk_size=25;
	      if(length<=max_chunk_size)
	      {
	          return std::accumulate(first,last,init);	// 2
	      }
	      else
	      {
	          Iterator mid_point=first;
	          std::advance(mid_point,length/2);	// 3
	          std::future<T> first_half_result=
	              std::async(parallel_accumulate<Iterator,T>,	// 4
	                         first,mid_point,init);
	          T second_half_result=parallel_accumulate(mid_point,last,T());	// 5
	          return first_half_result.get()+second_half_result;	// 6
	      }
	  }
	  ```
	- 这种设计十分巧妙，不仅充分利用了可供运行的并发硬件资源，而且满足异常安全。
	  在每一层递归中，`std::async()`  的调用会创建出一个 `future` 对象④，继而进入下一层递归调用⑤，若后者抛出异常，便会向上传递，令控制流程离开当前层级，导致该 `future` 被销毁。这会令代码等待异步任务完成，预防了悬空线程。另外，如果异步调用抛出异常，则被对应的 `future` 捕获，对应的 `get()`  的调用⑥则会重新抛出该异常。
-