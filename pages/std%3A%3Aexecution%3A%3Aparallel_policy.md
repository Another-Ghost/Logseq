alias:: 并行策略, parallel policy, std::execution::par

- ^^并行策略^^（parallel policy）给出了多个线程并行的基本模式。
  函数的内部操作可以在发起调用的线程上执行，也可以由程序库另外创建线程执行。
  若给定**一个线程，其上执行的操作必须服从一定的次序**，不得交错执行，但C++标准没有规定具体的次序，算法函数所服从的内存次序可能因调用不同而不同。给定一项操作，它会固定在一个线程上，完整执行到底。
- 算法函数用到了各种迭代器、值和可调用对象，在前面的[[顺序策略]]的基础上，并行策略对这些目标的内存次序施加了更多限制：若它们涉及并行操作，就绝不能引发[[数据竞争]]，也不得假设其他任何操作会由同一个线程执行，还不得假设其他任何操作一定会由别的线程执行。
- 标准库的算法函数能被调用而不设定执行策略，在绝大多数情况下，我们都可以令其采用并行策略。只有在下述情况下才会引发问题：某些元素的操作要求服从特定的次序，或共享数据的访问之间没有同步。
  我们可以采取并行策略，分别递增 vector 容器中 的每个值。
  ```cpp
  std::for_each(std::execution::par,v.begin(),v.end(),[](auto& x){++x;});
  ```
- 然而，前面的样例进行vect or 容器填充操作，若采用并行策略则会引发问题。具体 而言，会出现未定义行为。
  ```cpp
  std::for_each(std::execution::par,v.begin(),v.end(),
    [&](int& x){ x=++count; });
  ```
  这里，lambda 函数的每次调用都会改动变量 `count` ，若运行库要在多个线程上同时执行该 lambda 函数，就会导致数据竞争，进而诱发来定义行为。
  若先前发生的函数调用会干扰其后调用的运行，则会诱发未定义行为，即便标准库没有在多个线程上发起调用。`std:exccution::parallel_policy` 需预防这种情况。某项内部操作是否会诱发未定义行为，是其改调用的固定属性，并不取决于程序库的实现细节。
  然而，并行策略允许函数调用之间的[[同步操作]]，变量 `count` 本来属于普通的内建 `int` 类型，我们可以将它原子化成 `std::atomic<int>` 类型，或采用互斥保护，即可避免诱发未定义行为，使之符合C++标准的规范。就本例而言，这么做会违背并行策略的初衷，因为该 lambda 函数的所有调用都会按串行方式执行。但一般来说，上述做法能让多个调用同步访问共享数据。
-