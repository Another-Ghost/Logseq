alias:: 静态局部变量, 块作用域静态变量

- 在[[块作用域]]中用[[static]]或[[thread_local]]修饰符声明的变量具有 静态 或 线程存储期，但在第一次[[执行]]到其**声明**时才进行初始化（除非它们的初始化是[[零初始化]]或[[常量初始化]]，这可以在第一次进入 块 之前执行）。在所有后续调用中，将**跳过**该声明。这些类型变量称为[[静态局部变量]]
- 如果初始化抛出[[异常]]，该变量不被视为已初始化，并且下次控制流经其声明时将**再次尝试**初始化。
- 如果初始化递归进入正在初始化该变量的块，行为是未定义的。
- 如果多个[[线程]]同时尝试初始化同一个 静态局部变量，则初始化**仅发生一次**（使用 `std::call_once` 可以获得类似行为）。
  #+BEGIN_NOTE
  此功能的通常实现使用[[双检锁模式]]的变体，这将 已初始化的局部静态变量 的 运行时开销 减少到单个 非原子 布尔比较 。
  #+END_NOTE
- [[块作用域静态变量]]的析构函数在程序退出时调用，但前提是初始化成功进行。
- 同一[[内联函数]]（可能[[隐式内联]]）的所有定义中的 函数局部静态对象 都引用在一个[[翻译单元]]中定义的**同一个**对象，只要该函数具有[[外部链接]]。
-
- ## 注释
  在[[顶层命名空间作用域]]（C 中的 文件作用域 ）中，[[const]]且非[[extern]]的名称在[[C]]中具有[[外部链接]]，但在[[C++]]中具有[[内部链接]]。
  
  （自 C++17 起）
  具有内部或外部链接的 thread_local 变量的名称在不同作用域中引用时，可能指向相同或不同的实例，这取决于代码是在同一线程还是在不同线程中执行。
  
  extern 关键字还可以用来指定语言链接和显式模板实例化声明，但在这些情况下它不是存储类别说明符（除非声明直接包含在语言链接规范中，在这种情况下，声明
  
  被视为包含 extern 说明符）。
  
  关键字 mutable 在 C++ 语言语法中是存储类别说明符，尽管它不影响存储持续时间或链接。
- ### 本节未完成
  原因：关于在同一翻译单元中重新声明名称的规则。
  除 thread_local 外，存储类别说明符不允许用于显式特化和显式实例化：
  
  ```cpp
  template<class T>
  struct S {
    thread_local static int tlm;
  };
  
  template<>
  thread_local int S<float>::tlm = 0; // 这里不出现 "static"
  ```